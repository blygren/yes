<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Jelly Physics</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #121212;
            color: white;
            display: flex;
            justify-content: center;
        }

        .container {
            max-width: 1200px;
            width: 100%;
            padding: 20px;
        }

        h1 {
            text-align: center;
            color: #bb86fc;
        }

        .canvas-container {
            display: flex;
            justify-content: center;
            margin-bottom: 20px;
        }

        canvas {
            background-color: #1e1e1e;
            box-shadow: 0 0 20px rgba(187, 134, 252, 0.3);
            border-radius: 8px;
        }

        .controls {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }

        .slider-container {
            width: 300px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        button {
            background-color: #bb86fc;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            color: #121212;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s ease;
        }

        button:hover {
            background-color: #d7aefb;
            transform: translateY(-2px);
        }

        input[type="range"] {
            width: 200px;
        }

        .info {
            margin-top: 10px;
            font-style: italic;
            opacity: 0.7;
        }
        
        .button-container {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .color-picker {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .jelly-counter {
            margin-top: 15px;
            font-weight: bold;
            color: #bb86fc;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Interactive Jelly Physics</h1>
        <div class="canvas-container">
            <canvas id="jellySim"></canvas>
        </div>
        <div class="controls">
            <div class="button-container">
                <button id="resetBtn">Reset Jellies</button>
                <button id="spawnBtn">Spawn Jelly</button>
                <button id="clearBtn">Clear All</button>
            </div>
            
            <div class="slider-container">
                <label for="stiffness">Stiffness: </label>
                <input type="range" id="stiffness" min="0.01" max="0.5" step="0.01" value="0.2">
            </div>
            <div class="slider-container">
                <label for="gravity">Gravity: </label>
                <input type="range" id="gravity" min="0" max="2" step="0.1" value="0.8">
            </div>
            <div class="slider-container">
                <label for="size">Size: </label>
                <input type="range" id="size" min="50" max="200" step="10" value="150">
            </div>
            <div class="slider-container">
                <label for="bounce">Bounce: </label>
                <input type="range" id="bounce" min="0.1" max="1.0" step="0.1" value="0.7">
            </div>
            <div class="color-picker">
                <label for="jellyColor">Color: </label>
                <input type="color" id="jellyColor" value="#bb86fc">
            </div>
            <div class="jelly-counter">Jellies: 1</div>
            <div class="info">
                <p>Click and drag to play with the jellies!</p>
                <p>Press 'D' to toggle debug view</p>
            </div>
        </div>
    </div>

    <script>
        // Particle class
        class Particle {
            constructor(x, y, mass = 1) {
                this.pos = { x, y };
                this.oldPos = { x, y };
                this.velocity = { x: 0, y: 0 };
                this.acceleration = { x: 0, y: 0 };
                this.mass = mass;
                this.isFixed = false;
                this.radius = 4;
                this.color = '#bb86fc';
                this.isGrabbed = false;
            }

            update(dt, gravity) {
                if (this.isFixed || this.isGrabbed) return;
                
                // Store old position for verlet integration
                const oldX = this.pos.x;
                const oldY = this.pos.y;
                
                // Apply gravity
                this.acceleration.y = gravity;
                
                // Verlet integration
                this.pos.x = 2 * this.pos.x - this.oldPos.x + this.acceleration.x * dt * dt;
                this.pos.y = 2 * this.pos.y - this.oldPos.y + this.acceleration.y * dt * dt;
                
                // Save old position
                this.oldPos.x = oldX;
                this.oldPos.y = oldY;
                
                // Calculate velocity (for external use/visualization)
                this.velocity.x = (this.pos.x - this.oldPos.x) / dt;
                this.velocity.y = (this.pos.y - this.oldPos.y) / dt;
                
                // Reset acceleration
                this.acceleration.x = 0;
            }

            applyForce(force) {
                this.acceleration.x += force.x / this.mass;
                this.acceleration.y += force.y / this.mass;
            }

            constrain(width, height, bounce = 0.7) {
                if (this.isFixed) return;
                
                // Constrain to canvas bounds with bounce
                if (this.pos.x < this.radius) {
                    this.pos.x = this.radius;
                    this.oldPos.x = this.pos.x + (this.pos.x - this.oldPos.x) * bounce;
                } else if (this.pos.x > width - this.radius) {
                    this.pos.x = width - this.radius;
                    this.oldPos.x = this.pos.x + (this.pos.x - this.oldPos.x) * bounce;
                }
                
                if (this.pos.y < this.radius) {
                    this.pos.y = this.radius;
                    this.oldPos.y = this.pos.y + (this.pos.y - this.oldPos.y) * bounce;
                } else if (this.pos.y > height - this.radius) {
                    this.pos.y = height - this.radius;
                    this.oldPos.y = this.pos.y + (this.pos.y - this.oldPos.y) * bounce;
                }
            }

            draw(ctx) {
                ctx.beginPath();
                ctx.arc(this.pos.x, this.pos.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = this.isGrabbed ? '#03dac6' : this.color;
                ctx.fill();
            }
        }

        // SpringConstraint class
        class SpringConstraint {
            constructor(particleA, particleB, stiffness = 0.2, restLength = null) {
                this.particleA = particleA;
                this.particleB = particleB;
                this.stiffness = stiffness;
                
                // If no rest length specified, use current distance
                const dx = particleB.pos.x - particleA.pos.x;
                const dy = particleB.pos.y - particleA.pos.y;
                this.restLength = restLength || Math.sqrt(dx * dx + dy * dy);
                
                this.visible = true;
            }
            
            update() {
                // Calculate distance between particles
                const dx = this.particleB.pos.x - this.particleA.pos.x;
                const dy = this.particleB.pos.y - this.particleA.pos.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                // Skip if particles are at the same position
                if (distance === 0) return;
                
                // Calculate displacement from rest length
                const displacement = this.restLength - distance;
                
                // Calculate direction vector
                const dirX = dx / distance;
                const dirY = dy / distance;
                
                // Calculate the force to apply (proportional to displacement and stiffness)
                const force = displacement * this.stiffness;
                
                // Apply forces to both particles if they're not fixed
                if (!this.particleA.isFixed && !this.particleA.isGrabbed) {
                    this.particleA.pos.x -= dirX * force * 0.5;
                    this.particleA.pos.y -= dirY * force * 0.5;
                }
                
                if (!this.particleB.isFixed && !this.particleB.isGrabbed) {
                    this.particleB.pos.x += dirX * force * 0.5;
                    this.particleB.pos.y += dirY * force * 0.5;
                }
            }
            
            draw(ctx) {
                if (!this.visible) return;
                
                ctx.beginPath();
                ctx.moveTo(this.particleA.pos.x, this.particleA.pos.y);
                ctx.lineTo(this.particleB.pos.x, this.particleB.pos.y);
                
                // Visualization: color based on stretch/compression
                const dx = this.particleB.pos.x - this.particleA.pos.x;
                const dy = this.particleB.pos.y - this.particleA.pos.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const strain = Math.abs(distance - this.restLength) / this.restLength;
                
                // Gradient from blue (compressed) to green (rest) to red (stretched)
                let color;
                if (distance < this.restLength) {
                    // Compressed: blue to green
                    const t = distance / this.restLength;
                    color = `rgba(0, ${Math.floor(255 * t)}, ${Math.floor(255 * (1 - t))}, 0.3)`;
                } else {
                    // Stretched: green to red
                    const t = Math.min(1, (distance - this.restLength) / this.restLength);
                    color = `rgba(${Math.floor(255 * t)}, ${Math.floor(255 * (1 - t))}, 0, 0.3)`;
                }
                
                ctx.strokeStyle = color;
                ctx.lineWidth = 2 - strain * 1.5;  // Thinner when stretched
                ctx.stroke();
            }
        }

        // Jelly class
        class Jelly {
            constructor(centerX, centerY, width = 100, height = 100, particlesX = 8, particlesY = 8, options = {}) {
                this.center = { x: centerX, y: centerY };
                this.width = width;
                this.height = height;
                this.particlesX = particlesX;
                this.particlesY = particlesY;
                
                this.particles = [];
                this.springs = [];
                this.tentacles = [];
                
                // Internal spring parameters
                this.stiffness = options.stiffness || 0.2;
                this.damping = 0.03;
                this.bounce = options.bounce || 0.7;
                this.color = options.color || '#bb86fc';
                
                // Collision properties
                this.boundingBox = { left: 0, top: 0, right: 0, bottom: 0 };
                this.collisionRadius = Math.max(width, height) / 1.8;
                this.mass = width * height / 2000; // Approximate mass based on size
                
                // Growth/Food properties
                this.energy = 100; // Energy level
                this.growthFactor = 1.0; // Size multiplier
                this.maxSize = 300; // Maximum size
                this.minSize = 50;  // Minimum size
                
                // Initialize the jelly
                this.init();
            }
            
            init() {
                // Clear any existing particles and springs
                this.particles = [];
                this.springs = [];
                this.tentacles = [];
                
                // Create particles in a grid
                const startX = this.center.x - this.width / 2;
                const startY = this.center.y - this.height / 2;
                const stepX = this.width / (this.particlesX - 1);
                const stepY = this.height / (this.particlesY - 1);
                
                // Create particles
                for (let y = 0; y < this.particlesY; y++) {
                    for (let x = 0; x < this.particlesX; x++) {
                        const px = startX + x * stepX;
                        const py = startY + y * stepY;
                        
                        const particle = new Particle(px, py);
                        particle.color = this.color;
                        
                        // Particles on the edge have smaller radius
                        if (x === 0 || x === this.particlesX - 1 || y === 0 || y === this.particlesY - 1) {
                            particle.radius = 3;
                        }
                        
                        // Add some random variation to make it look more organic
                        particle.pos.x += (Math.random() - 0.5) * 5;
                        particle.pos.y += (Math.random() - 0.5) * 5;
                        
                        // Copy to old position for consistent starting state
                        particle.oldPos.x = particle.pos.x;
                        particle.oldPos.y = particle.pos.y;
                        
                        this.particles.push(particle);
                    }
                }
                
                // Create springs between adjacent particles
                for (let y = 0; y < this.particlesY; y++) {
                    for (let x = 0; x < this.particlesX; x++) {
                        const i = y * this.particlesX + x;
                        
                        // Connect to right neighbor
                        if (x < this.particlesX - 1) {
                            const rightNeighbor = y * this.particlesX + (x + 1);
                            this.springs.push(new SpringConstraint(
                                this.particles[i], 
                                this.particles[rightNeighbor], 
                                this.stiffness
                            ));
                        }
                        
                        // Connect to bottom neighbor
                        if (y < this.particlesY - 1) {
                            const bottomNeighbor = (y + 1) * this.particlesX + x;
                            this.springs.push(new SpringConstraint(
                                this.particles[i], 
                                this.particles[bottomNeighbor],
                                this.stiffness
                            ));
                        }
                        
                        // Add diagonal connections for stability
                        if (x < this.particlesX - 1 && y < this.particlesY - 1) {
                            // Diagonal: bottom-right
                            const diagonalNeighbor = (y + 1) * this.particlesX + (x + 1);
                            this.springs.push(new SpringConstraint(
                                this.particles[i], 
                                this.particles[diagonalNeighbor],
                                this.stiffness * 0.8,
                                null
                            ));
                            
                            // Anti-diagonal: bottom-left (if not at left edge)
                            if (x > 0) {
                                const antiDiagonalNeighbor = (y + 1) * this.particlesX + (x - 1);
                                this.springs.push(new SpringConstraint(
                                    this.particles[i], 
                                    this.particles[antiDiagonalNeighbor],
                                    this.stiffness * 0.8,
                                    null
                                ));
                            }
                        }
                    }
                }
                
                // Add tentacles on the bottom row
                this.createTentacles();
            }
            
            // Create tentacles at the bottom of the jelly
            createTentacles() {
                const tentacleCount = Math.floor(this.width / 30); // Number of tentacles based on width
                const bottomRowY = this.particlesY - 1;
                const segmentLength = 20; // Length of each tentacle segment
                const tentacleSegments = 5; // Number of segments per tentacle
                
                for (let i = 0; i < tentacleCount; i++) {
                    // Distribute tentacles evenly along the bottom
                    const x = Math.round(i * (this.particlesX - 1) / (tentacleCount - 1));
                    if (x >= this.particlesX) continue;
                    
                    const startParticle = this.particles[bottomRowY * this.particlesX + x];
                    let prevParticle = startParticle;
                    
                    // Create a chain of particles for each tentacle
                    const tentacle = [];
                    for (let j = 0; j < tentacleSegments; j++) {
                        const py = prevParticle.pos.y + segmentLength;
                        const particle = new Particle(prevParticle.pos.x, py);
                        particle.radius = 3 - j * 0.4; // Make particles smaller towards the end
                        particle.color = this.color;
                        this.particles.push(particle);
                        tentacle.push(particle);
                        
                        // Create a spring connecting to the previous particle
                        const spring = new SpringConstraint(prevParticle, particle, this.stiffness * 0.4, segmentLength);
                        this.springs.push(spring);
                        
                        prevParticle = particle;
                    }
                    
                    this.tentacles.push(tentacle);
                }
            }
            
            update(dt, gravity, frameCount) {
                // Update bounding box
                this.updateBoundingBox();
                
                // Update constraints multiple times for stability
                const iterations = 3;
                for (let i = 0; i < iterations; i++) {
                    for (const spring of this.springs) {
                        spring.update();
                    }
                }
                
                // Update particles
                for (const particle of this.particles) {
                    particle.update(dt, gravity);
                }
                
                // Update center position
                this.getCenter();
                
                // Apply small random forces to tentacle tips for movement
                this.animateTentacles();
            }
            
            // Apply small random forces to tentacles for natural movement
            animateTentacles() {
                for (const tentacle of this.tentacles) {
                    if (tentacle.length > 0) {
                        // Apply random force to tip
                        const tip = tentacle[tentacle.length - 1];
                        tip.applyForce({
                            x: (Math.random() - 0.5) * 0.5,
                            y: (Math.random() - 0.5) * 0.5
                        });
                    }
                }
            }
            
            // Update the bounding box for collision optimization
            updateBoundingBox() {
                let minX = Infinity, minY = Infinity;
                let maxX = -Infinity, maxY = -Infinity;
                
                for (const particle of this.particles) {
                    if (particle.pos.x < minX) minX = particle.pos.x;
                    if (particle.pos.y < minY) minY = particle.pos.y;
                    if (particle.pos.x > maxX) maxX = particle.pos.x;
                    if (particle.pos.y > maxY) maxY = particle.pos.y;
                }
                
                this.boundingBox = {
                    left: minX,
                    top: minY,
                    right: maxX,
                    bottom: maxY,
                    width: maxX - minX,
                    height: maxY - minY
                };
            }
            
            // Eat food and grow
            eatFood(foodValue) {
                this.energy += foodValue;
                
                // Grow the jelly based on energy
                if (this.width < this.maxSize) {
                    const newSize = Math.min(
                        this.maxSize,
                        this.width + foodValue / 20
                    );
                    this.growTo(newSize);
                }
            }
            
            // Grow or shrink to a specific size
            growTo(newSize) {
                const scaleFactor = newSize / this.width;
                this.width = newSize;
                this.height = newSize;
                
                // Update center position
                const center = this.getCenter();
                
                // Scale all particle positions from the center
                for (const particle of this.particles) {
                    // Calculate offset from center
                    const offsetX = particle.pos.x - center.x;
                    const offsetY = particle.pos.y - center.y;
                    
                    // Scale by the factor
                    const newX = center.x + offsetX * scaleFactor;
                    const newY = center.y + offsetY * scaleFactor;
                    
                    // Update positions
                    particle.pos.x = newX;
                    particle.pos.y = newY;
                    particle.oldPos.x = newX;
                    particle.oldPos.y = newY;
                }
                
                // Update spring rest lengths
                for (const spring of this.springs) {
                    const dx = spring.particleB.pos.x - spring.particleA.pos.x;
                    const dy = spring.particleB.pos.y - spring.particleA.pos.y;
                    spring.restLength = Math.sqrt(dx * dx + dy * dy);
                }
                
                // Update collision radius
                this.collisionRadius = Math.max(this.width, this.height) / 1.8;
                this.mass = this.width * this.height / 2000; // Update mass
            }
            
            constrain(width, height) {
                for (const particle of this.particles) {
                    particle.constrain(width, height, this.bounce);
                }
            }
            
            // Check and resolve collisions with another jelly
            checkCollision(otherJelly) {
                // First do a quick bounding box check for optimization
                if (!this.boundingBoxesOverlap(this.boundingBox, otherJelly.boundingBox)) {
                    return false; // No collision
                }
                
                // Center-based check for approximate collision
                const dx = this.center.x - otherJelly.center.x;
                const dy = this.center.y - otherJelly.center.y;
                const distSq = dx * dx + dy * dy;
                const minDist = this.collisionRadius + otherJelly.collisionRadius;
                
                if (distSq >= minDist * minDist) {
                    return false; // No collision
                }
                
                // We have a collision between jellies
                const dist = Math.sqrt(distSq) || 0.001;
                const overlap = (minDist - dist) / 2;
                
                // Direction to push jellies apart
                const dirX = dx / dist;
                const dirY = dy / dist;
                
                // Calculate force based on masses to make larger jellies move less
                const totalMass = this.mass + otherJelly.mass;
                const thisRatio = otherJelly.mass / totalMass;
                const otherRatio = this.mass / totalMass;
                
                // Apply repulsion to each particle of this jelly
                for (const particle of this.particles) {
                    if (!particle.isGrabbed) {
                        particle.pos.x += dirX * overlap * thisRatio * 0.5;
                        particle.pos.y += dirY * overlap * thisRatio * 0.5;
                    }
                }
                
                // Apply repulsion to each particle of the other jelly
                for (const particle of otherJelly.particles) {
                    if (!particle.isGrabbed) {
                        particle.pos.x -= dirX * overlap * otherRatio * 0.5;
                        particle.pos.y -= dirY * overlap * otherRatio * 0.5;
                    }
                }
                
                return true; // Collision occurred
            }
            
            // Utility function to check if bounding boxes overlap
            boundingBoxesOverlap(boxA, boxB) {
                return !(
                    boxA.right < boxB.left ||
                    boxA.left > boxB.right ||
                    boxA.bottom < boxB.top ||
                    boxA.top > boxB.bottom
                );
            }
            
            // Calculate approximate center position
            getCenter() {
                let sumX = 0, sumY = 0;
                const bodyParticles = this.particles.slice(0, this.particlesX * this.particlesY);
                
                for (const particle of bodyParticles) {
                    sumX += particle.pos.x;
                    sumY += particle.pos.y;
                }
                
                this.center.x = sumX / bodyParticles.length;
                this.center.y = sumY / bodyParticles.length;
                return this.center;
            }
            
            // Split the jelly into two smaller ones
            split() {
                if (this.width < this.minSize * 1.5) return null; // Too small to split
                
                const newSize = this.width * 0.7;
                this.growTo(newSize);
                
                // Create a new jelly nearby
                const angle = Math.random() * Math.PI * 2;
                const distance = this.width * 0.7;
                const newX = this.center.x + Math.cos(angle) * distance;
                const newY = this.center.y + Math.sin(angle) * distance;
                
                return new Jelly(newX, newY, newSize, newSize, 8, 8, {
                    stiffness: this.stiffness,
                    bounce: this.bounce,
                    color: this.color
                });
            }
            
            // Draw the jelly body
            drawJellyBody(ctx) {
                // Get outer particles for the body shape
                const points = [];
                
                // Add the outer particles in order to form the shape
                // Top row
                for (let x = 0; x < this.particlesX; x++) {
                    points.push(this.particles[x]);
                }
                
                // Right column (excluding top and bottom corners)
                for (let y = 1; y < this.particlesY - 1; y++) {
                    points.push(this.particles[y * this.particlesX + this.particlesX - 1]);
                }
                
                // Bottom row (right to left)
                for (let x = this.particlesX - 1; x >= 0; x--) {
                    points.push(this.particles[(this.particlesY - 1) * this.particlesX + x]);
                }
                
                // Left column (excluding bottom and top corners)
                for (let y = this.particlesY - 2; y > 0; y--) {
                    points.push(this.particles[y * this.particlesX]);
                }
                
                // Draw the shape with gradient fill
                ctx.beginPath();
                ctx.moveTo(points[0].pos.x, points[0].pos.y);
                
                for (let i = 0; i < points.length; i++) {
                    const current = points[i];
                    const next = points[(i + 1) % points.length];
                    
                    // Use midpoint for control points for a smoother curve
                    const midX = (current.pos.x + next.pos.x) / 2;
                    const midY = (current.pos.y + next.pos.y) / 2;
                    
                    ctx.quadraticCurveTo(current.pos.x, current.pos.y, midX, midY);
                }
                
                ctx.closePath();
                
                // Parse the color
                const baseColor = this.color;
                
                // Create gradient fill based on the selected color
                const centerX = this.center.x;
                const centerY = this.center.y;
                const gradient = ctx.createRadialGradient(
                    centerX, centerY, 0,
                    centerX, centerY, this.width / 1.5
                );
                
                // Create lighter and darker versions of the base color
                const r = parseInt(baseColor.slice(1, 3), 16);
                const g = parseInt(baseColor.slice(3, 5), 16);
                const b = parseInt(baseColor.slice(5, 7), 16);
                
                // Lighter color
                const lighterColor = `rgba(${Math.min(255, r + 50)}, ${Math.min(255, g + 50)}, ${Math.min(255, b + 50)}, 0.8)`;
                // Base color
                const baseColorAlpha = `rgba(${r}, ${g}, ${b}, 0.7)`;
                // Darker color
                const darkerColor = `rgba(${Math.max(0, r - 70)}, ${Math.max(0, g - 70)}, ${Math.max(0, b - 70)}, 0.6)`;
                
                gradient.addColorStop(0, lighterColor);
                gradient.addColorStop(0.5, baseColorAlpha);
                gradient.addColorStop(1, darkerColor);
                
                ctx.fillStyle = gradient;
                ctx.fill();
                
                // Add a subtle glow effect
                ctx.shadowColor = baseColor;
                ctx.shadowBlur = 15;
                ctx.strokeStyle = baseColorAlpha;
                ctx.lineWidth = 2;
                ctx.stroke();
                ctx.shadowBlur = 0;
            }
            
            // Draw the jelly
            draw(ctx, showDebug = false) {
                // Draw the jelly body
                this.drawJellyBody(ctx);
                // Optionally draw particles for debugging
                if (showDebug) {
                    for (const particle of this.particles) {
                        particle.draw(ctx);
                    }
                }
            }
            
            // Get the closest particle to a given point
            getClosestParticle(x, y) {
                let closest = null;
                let minDist = Infinity;
                for (const particle of this.particles) {
                    const dx = particle.pos.x - x;
                    const dy = particle.pos.y - y;
                    const distSq = dx * dx + dy * dy;
                    if (distSq < minDist) {
                        minDist = distSq;
                        closest = particle;
                    }
                }
                // Only select particle if within 30 pixels radius
                return Math.sqrt(minDist) > 30 ? null : closest;
            }
        }

        // Food particle class
        class FoodParticle {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.radius = 5 + Math.random() * 5;
                this.value = this.radius * 2; // Larger particles are worth more
                this.color = this.getRandomColor();
                this.velocityY = 0.5 + Math.random() * 0.5;
                this.velocityX = (Math.random() - 0.5) * 0.5;
                this.alpha = 1.0;
                this.eaten = false;
            }
            
            getRandomColor() {
                const colors = [
                    '#ff5a5f', // Red
                    '#3fb8af', // Teal
                    '#7fc7af', // Green
                    '#dad8a7', // Yellow
                    '#ff9e9d', // Pink
                    '#ff3d7f'  // Bright pink
                ];
                return colors[Math.floor(Math.random() * colors.length)];
            }
            
            update() {
                this.y += this.velocityY;
                this.x += this.velocityX;
                
                // Add some wiggle
                this.x += (Math.random() - 0.5) * 0.5;
            }
            
            draw(ctx) {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                
                // Create gradient
                const gradient = ctx.createRadialGradient(
                    this.x, this.y, 0,
                    this.x, this.y, this.radius
                );
                
                gradient.addColorStop(0, this.color + 'ff');
                gradient.addColorStop(1, this.color + '88');
                
                ctx.fillStyle = gradient;
                ctx.fill();
                
                // Add glow effect
                ctx.shadowColor = this.color;
                ctx.shadowBlur = 10;
                ctx.fill();
                ctx.shadowBlur = 0;
            }
            
            // Check if food is being eaten by a jelly
            checkEaten(jelly) {
                if (this.eaten) return false;
                
                // Check if the food is inside the jelly body
                const dx = this.x - jelly.center.x;
                const dy = this.y - jelly.center.y;
                const distSq = dx * dx + dy * dy;
                
                // If within the collision radius, consider it eaten
                if (distSq < jelly.collisionRadius * jelly.collisionRadius * 0.7) {
                    this.eaten = true;
                    return true;
                }
                
                return false;
            }
        }

        // Main application code
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('jellySim');
            const ctx = canvas.getContext('2d');
            
            // Canvas setup
            canvas.width = 800;
            canvas.height = 600;
            
            // Settings
            let gravity = 0.8;
            let showDebug = false;
            let grabbing = false;
            let grabbedParticle = null;
            let lastMousePos = { x: 0, y: 0 };
            let stiffness = 0.2;
            let jellies = [];
            let bounce = 0.7;
            let jellySize = 150;
            let jellyColor = '#bb86fc';
            let frameCount = 0;
            
            // Food system
            let foodParticles = [];
            let autoFeedEnabled = false;
            let lastFoodTime = 0;
            
            // Create initial jelly
            function createJelly(x, y) {
                const size = jellySize;
                const newJelly = new Jelly(x, y, size, size, 8, 8, {
                    stiffness: stiffness,
                    bounce: bounce,
                    color: jellyColor
                });
                return newJelly;
            }
            
            // Initialize with one jelly
            jellies.push(createJelly(canvas.width / 2, canvas.height / 2));
            
            // Create food particle
            function createFoodParticle() {
                // Random position along the top of the canvas
                const x = Math.random() * canvas.width;
                const y = -10; // Start above the canvas
                foodParticles.push(new FoodParticle(x, y));
            }
            
            // Update jelly counter
            function updateJellyCounter() {
                const counter = document.querySelector('.jelly-counter');
                counter.textContent = `Jellies: ${jellies.length}`;
            }
            
            // Add UI controls
            const controls = document.querySelector('.controls');
            
            // Add auto-feed toggle button
            const autoFeedDiv = document.createElement('div');
            autoFeedDiv.className = 'button-container';
            autoFeedDiv.innerHTML = `
                <button id="feedBtn">Drop Food</button>
                <button id="autoFeedToggle">Auto Feed: OFF</button>
                <button id="splitJellyBtn">Split Jelly</button>
            `;
            controls.appendChild(autoFeedDiv);
            
            // Add food counter
            const foodCounterDiv = document.createElement('div');
            foodCounterDiv.className = 'jelly-counter';
            foodCounterDiv.textContent = 'Food: 0';
            controls.appendChild(foodCounterDiv);
            
            // UI controls
            const stiffnessSlider = document.getElementById('stiffness');
            stiffnessSlider.addEventListener('input', (e) => {
                stiffness = parseFloat(e.target.value);
                jellies.forEach(jelly => jelly.setStiffness(stiffness));
            });
            
            const gravitySlider = document.getElementById('gravity');
            gravitySlider.addEventListener('input', (e) => {
                gravity = parseFloat(e.target.value);
            });
            
            const sizeSlider = document.getElementById('size');
            sizeSlider.addEventListener('input', (e) => {
                jellySize = parseFloat(e.target.value);
            });
            
            const bounceSlider = document.getElementById('bounce');
            bounceSlider.addEventListener('input', (e) => {
                bounce = parseFloat(e.target.value);
                jellies.forEach(jelly => jelly.setBounce(bounce));
            });
            
            const colorPicker = document.getElementById('jellyColor');
            colorPicker.addEventListener('input', (e) => {
                jellyColor = e.target.value;
            });
            
            const resetBtn = document.getElementById('resetBtn');
            resetBtn.addEventListener('click', () => {
                jellies = [createJelly(canvas.width / 2, canvas.height / 2)];
                updateJellyCounter();
            });
            
            const spawnBtn = document.getElementById('spawnBtn');
            spawnBtn.addEventListener('click', () => {
                if (jellies.length < 10) { // Limit to 10 jellies for performance
                    // Spawn at a random position
                    const x = 100 + Math.random() * (canvas.width - 200);
                    const y = 100 + Math.random() * (canvas.height - 200);
                    jellies.push(createJelly(x, y));
                    updateJellyCounter();
                }
            });
            
            const clearBtn = document.getElementById('clearBtn');
            clearBtn.addEventListener('click', () => {
                jellies = [];
                updateJellyCounter();
            });
            
            // New UI controls
            const feedBtn = document.getElementById('feedBtn');
            feedBtn.addEventListener('click', () => {
                // Create 5 food particles at once
                for (let i = 0; i < 5; i++) {
                    createFoodParticle();
                }
            });
            
            const autoFeedToggle = document.getElementById('autoFeedToggle');
            autoFeedToggle.addEventListener('click', () => {
                autoFeedEnabled = !autoFeedEnabled;
                autoFeedToggle.textContent = `Auto Feed: ${autoFeedEnabled ? 'ON' : 'OFF'}`;
            });
            
            const splitJellyBtn = document.getElementById('splitJellyBtn');
            splitJellyBtn.addEventListener('click', () => {
                if (jellies.length > 0 && jellies.length < 10) {
                    // Find the largest jelly
                    let largestJellyIndex = 0;
                    let largestSize = jellies[0].width;
                    
                    for (let i = 1; i < jellies.length; i++) {
                        if (jellies[i].width > largestSize) {
                            largestSize = jellies[i].width;
                            largestJellyIndex = i;
                        }
                    }
                    
                    // Try to split it
                    const newJelly = jellies[largestJellyIndex].split();
                    if (newJelly) {
                        jellies.push(newJelly);
                        updateJellyCounter();
                    }
                }
            });
            
            // Mouse interaction
            canvas.addEventListener('mousedown', (e) => {
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                
                // Find closest particle from any jelly
                for (const jelly of jellies) {
                    const particle = jelly.getClosestParticle(mouseX, mouseY);
                    if (particle) {
                        grabbedParticle = particle;
                        grabbing = true;
                        grabbedParticle.isGrabbed = true;
                        lastMousePos = { x: mouseX, y: mouseY };
                        break;
                    }
                }
            });
            
            canvas.addEventListener('mousemove', (e) => {
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                
                if (grabbing && grabbedParticle) {
                    // Update particle position based on mouse movement
                    grabbedParticle.pos.x = mouseX;
                    grabbedParticle.pos.y = mouseY;
                    
                    // Calculate velocity for realistic throwing
                    grabbedParticle.velocity.x = mouseX - lastMousePos.x;
                    grabbedParticle.velocity.y = mouseY - lastMousePos.y;
                    
                    lastMousePos = { x: mouseX, y: mouseY };
                }
            });
            
            canvas.addEventListener('mouseup', () => {
                if (grabbedParticle) {
                    // Apply the current velocity to the particle's old position for momentum
                    grabbedParticle.oldPos.x = grabbedParticle.pos.x - grabbedParticle.velocity.x;
                    grabbedParticle.oldPos.y = grabbedParticle.pos.y - grabbedParticle.velocity.y;
                    grabbedParticle.isGrabbed = false;
                }
                
                grabbing = false;
                grabbedParticle = null;
            });
            
            // Touch support
            canvas.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const rect = canvas.getBoundingClientRect();
                const touch = e.touches[0];
                const touchX = touch.clientX - rect.left;
                const touchY = touch.clientY - rect.top;
                
                // Find closest particle from any jelly
                for (const jelly of jellies) {
                    const particle = jelly.getClosestParticle(touchX, touchY);
                    if (particle) {
                        grabbedParticle = particle;
                        grabbing = true;
                        grabbedParticle.isGrabbed = true;
                        lastMousePos = { x: touchX, y: touchY };
                        break;
                    }
                }
            });
            
            canvas.addEventListener('touchmove', (e) => {
                e.preventDefault();
                const rect = canvas.getBoundingClientRect();
                const touch = e.touches[0];
                const touchX = touch.clientX - rect.left;
                const touchY = touch.clientY - rect.top;
                
                if (grabbing && grabbedParticle) {
                    grabbedParticle.pos.x = touchX;
                    grabbedParticle.pos.y = touchY;
                    
                    grabbedParticle.velocity.x = touchX - lastMousePos.x;
                    grabbedParticle.velocity.y = touchY - lastMousePos.y;
                    
                    lastMousePos = { x: touchX, y: touchY };
                }
            });
            
            canvas.addEventListener('touchend', () => {
                if (grabbedParticle) {
                    grabbedParticle.oldPos.x = grabbedParticle.pos.x - grabbedParticle.velocity.x;
                    grabbedParticle.oldPos.y = grabbedParticle.pos.y - grabbedParticle.velocity.y;
                    grabbedParticle.isGrabbed = false;
                }
                
                grabbing = false;
                grabbedParticle = null;
            });
            
            // Debug mode toggle with 'D' key
            document.addEventListener('keydown', (e) => {
                if (e.key.toLowerCase() === 'd') {
                    showDebug = !showDebug;
                }
            });
            
            // Animation loop
            let lastTime = 0;
            function animate(timestamp) {
                const dt = timestamp - lastTime;
                lastTime = timestamp;
                frameCount++;
                
                // Process physics only if a reasonable amount of time has passed
                // and limit dt to prevent instability with large gaps
                const frameTime = Math.min(dt, 30) / 1000;
                
                // Clear canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Auto-feed logic
                if (autoFeedEnabled && timestamp - lastFoodTime > 1000) {
                    createFoodParticle();
                    lastFoodTime = timestamp;
                }
                
                // Update and draw food particles
                for (let i = foodParticles.length - 1; i >= 0; i--) {
                    const food = foodParticles[i];
                    food.update();
                    food.draw(ctx);
                    
                    // Check if food is out of bounds
                    if (food.y > canvas.height + 20) {
                        foodParticles.splice(i, 1);
                        continue;
                    }
                    
                    // Check if food is eaten by any jelly
                    for (const jelly of jellies) {
                        if (food.checkEaten(jelly)) {
                            jelly.eatFood(food.value);
                            foodParticles.splice(i, 1);
                            break;
                        }
                    }
                }
                
                // Update food counter
                foodCounterDiv.textContent = `Food: ${foodParticles.length}`;
                
                // Update simulation for all jellies
                jellies.forEach(jelly => {
                    jelly.update(frameTime, gravity, frameCount);
                    jelly.constrain(canvas.width, canvas.height);
                });
                
                // Check collisions between jellies
                for (let i = 0; i < jellies.length; i++) {
                    for (let j = i + 1; j < jellies.length; j++) {
                        jellies[i].checkCollision(jellies[j]);
                    }
                }
                
                // Draw all jellies
                jellies.forEach(jelly => {
                    jelly.draw(ctx, showDebug);
                });
                
                // Debug info
                if (showDebug) {
                    ctx.fillStyle = 'white';
                    ctx.font = '14px Arial';
                    let totalParticles = 0;
                    let totalSprings = 0;
                    jellies.forEach(jelly => {
                        totalParticles += jelly.particles.length;
                        totalSprings += jelly.springs.length;
                    });
                    ctx.fillText(`Jellies: ${jellies.length}`, 10, 20);
                    ctx.fillText(`Particles: ${totalParticles}`, 10, 40);
                    ctx.fillText(`Springs: ${totalSprings}`, 10, 60);
                    ctx.fillText(`FPS: ${Math.round(1000 / dt)}`, 10, 80);
                    ctx.fillText(`Food: ${foodParticles.length}`, 10, 100);
                    ctx.fillText(`Press 'D' to toggle debug view`, 10, 120);
                    
                    // Draw jelly collision circles and bounding boxes
                    jellies.forEach(jelly => {
                        // Draw collision circle
                        ctx.beginPath();
                        ctx.arc(jelly.center.x, jelly.center.y, jelly.collisionRadius, 0, Math.PI * 2);
                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                        ctx.stroke();
                        
                        // Draw bounding box
                        ctx.strokeRect(
                            jelly.boundingBox.left,
                            jelly.boundingBox.top,
                            jelly.boundingBox.width,
                            jelly.boundingBox.height
                        );
                    });
                }
                
                requestAnimationFrame(animate);
            }
            
            // Start animation
            requestAnimationFrame(animate);
        });
    </script>
</body>
</html>