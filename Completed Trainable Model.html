<html>
<head>
  <title>Chatbot</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500&display=swap" rel="stylesheet">
  <style>
    :root {
      /* Light theme */
      --primary: #3498db;
      --primary-dark: #2980b9;
      --secondary: #2c3e50;
      --light: #ecf0f1;
      --dark: #34495e;
      --success: #2ecc71;
      --danger: #e74c3c;
      --gray: #95a5a6;
      --border-radius: 8px;
      
      /* Background and text colors */
      --bg-main: #f5f8fa;
      --bg-container: white;
      --bg-panel: #fafafa;
      --text-primary: #2c3e50;
      --text-secondary: #7f8c8d;
      --border-color: #e1e8ed;
      
      /* Message colors */
      --user-msg-bg: var(--primary);
      --user-msg-text: white;
      --bot-msg-bg: #f1f1f1;
      --bot-msg-text: var(--dark);
      
      /* Chart colors */
      --chart-bg: #f8f9fa;
      --chart-bar: linear-gradient(90deg, var(--primary) 0%, var(--success) 100%);
    }
    
    /* Dark theme variables */
    [data-theme="dark"] {
      --bg-main: #1a1e24;
      --bg-container: #293039;
      --bg-panel: #212b35;
      --text-primary: #ecf0f1;
      --text-secondary: #bdc3c7;
      --border-color: #445566;
      
      /* Message colors */
      --user-msg-bg: #3498db;
      --user-msg-text: #ecf0f1;
      --bot-msg-bg: #3a4754;
      --bot-msg-text: #ecf0f1;
      
      /* Chart colors */
      --chart-bg: #212b35;
      --chart-bar: linear-gradient(90deg, #3498db 0%, #2ecc71 100%);
    }
    
    /* Theme toggle styles */
    .theme-toggle {
      cursor: pointer;
      width: 24px;
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      margin-left: 10px;
      background: rgba(255,255,255,0.2);
      border-radius: 50%;
    }
    
    * {
      box-sizing: border-box;
      transition: all 0.2s ease;
    }
    
    body {
      font-family: 'Roboto', sans-serif;
      margin: 0;
      padding: 0;
      background-color: var(--bg-main);
      color: var(--text-primary);
      line-height: 1.6;
    }
    
    .chat-container {
      max-width: 1000px;
      margin: 20px auto;
      background-color: var(--bg-container);
      border-radius: var(--border-radius);
      box-shadow: 0 5px 15px rgba(0,0,0,0.1);
      overflow: hidden;
    }
    
    .chat-header {
      /* Header styles remain gradient for both themes */
      background: linear-gradient(135deg, var(--primary), var(--primary-dark));
      color: white;
      padding: 20px;
      font-size: 22px;
      font-weight: 500;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    
    .chat-header-icon {
      width: 30px;
      height: 30px;
      background-color: rgba(255,255,255,0.2);
      border-radius: 50%;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      margin-right: 10px;
    }
    
    .chat-header-actions {
      display: flex;
      align-items: center;
    }
    
    #chatbox {
      width: 100%;
      height: 500px;
      overflow-y: auto;
      padding: 20px;
      box-sizing: border-box;
      scroll-behavior: smooth;
      background-color: var(--bg-panel);
    }
    
    .input-area {
      display: flex;
      padding: 15px;
      border-top: 1px solid var(--border-color);
      background-color: var(--bg-container);
    }
    
    #userInput {
      flex: 1;
      padding: 15px;
      border: 1px solid var(--border-color);
      border-radius: var(--border-radius);
      font-size: 16px;
      box-shadow: inset 0 1px 3px rgba(0,0,0,0.05);
      background-color: var(--bg-panel);
      color: var(--text-primary);
    }
    
    #userInput:focus {
      outline: none;
      border-color: var(--primary);
      box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.2);
    }
    
    #sendBtn {
      padding: 0 20px;
      background-color: var(--primary);
      color: white;
      border: none;
      border-radius: var(--border-radius);
      margin-left: 10px;
      cursor: pointer;
      font-size: 16px;
      font-weight: 500;
    }
    
    #sendBtn:hover {
      background-color: var(--primary-dark);
      transform: translateY(-1px);
    }
    
    .message {
      margin-bottom: 15px;
      padding: 12px 18px;
      border-radius: 18px;
      max-width: 70%;
      word-wrap: break-word;
      position: relative;
      animation: fadeIn 0.3s ease;
    }
    
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }
    
    .user-message {
      background-color: var(--user-msg-bg);
      color: var(--user-msg-text);
      margin-left: auto;
      border-bottom-right-radius: 4px;
    }
    
    .bot-message {
      background-color: var(--bot-msg-bg);
      color: var(--bot-msg-text);
      margin-right: auto;
      border-bottom-left-radius: 4px;
    }
    
    .message-info {
      font-size: 12px;
      margin-bottom: 5px;
      opacity: 0.7;
    }
    
    .user-info {
      color: #fff;
      text-align: right;
    }
    
    .bot-info {
      color: var(--dark);
    }
    
    .help-text {
      font-size: 12px;
      color: #777;
      margin-top: 10px;
      text-align: center;
    }
    
    .training-toggle {
      cursor: pointer;
      text-decoration: underline;
      color: #4a76a8;
      margin: 10px 0;
      text-align: center;
    }
    
    .training-panel {
      background-color: var(--bg-container);
      border-top: 1px solid var(--border-color);
      padding: 20px;
      display: none;
    }
    
    .training-panel h3 {
      margin-top: 0;
      color: #4a76a8;
    }
    
    .training-form {
      display: flex;
      flex-direction: column;
      gap: 15px;
    }
    
    .training-form input, .training-form textarea {
      padding: 15px;
      border: 1px solid var(--border-color);
      border-radius: var(--border-radius);
      font-size: 16px;
    }
    
    .training-form textarea {
      min-height: 100px;
      resize: vertical;
    }
    
    .training-form button {
      padding: 15px;
      background-color: var(--primary);
      color: white;
      border: none;
      border-radius: var(--border-radius);
      cursor: pointer;
      font-weight: 500;
      font-size: 16px;
    }
    
    .training-form button:hover {
      background-color: var(--primary-dark);
      transform: translateY(-1px);
    }
    
    .trained-items {
      margin-top: 15px;
      max-height: 200px;
      overflow-y: auto;
      border: 1px solid var(--border-color);
      border-radius: 4px;
    }
    
    .trained-item {
      padding: 8px 10px;
      border-bottom: 1px solid var(--border-color);
      display: flex;
      justify-content: space-between;
    }
    
    .trained-item:last-child {
      border-bottom: none;
    }
    
    .delete-trained {
      color: #ff5555;
      cursor: pointer;
    }
    
    .tab-container {
      display: flex;
      margin-bottom: 15px;
      border-radius: var(--border-radius);
      overflow: hidden;
      background-color: var(--bg-panel);
    }
    
    .tab {
      padding: 12px 15px;
      cursor: pointer;
      flex: 1;
      text-align: center;
      font-weight: 500;
    }
    
    .tab.active {
      background-color: var(--primary);
      color: white;
    }
    
    .word-chip {
      display: inline-block;
      background-color: #e3eeff;
      border-radius: 16px;
      padding: 4px 12px;
      margin: 4px;
      font-size: 14px;
    }
    
    .meaning-text {
      color: #555;
      font-style: italic;
    }
    
    .training-stats {
      background-color: #f8f9fa;
      padding: 15px;
      border-radius: var(--border-radius);
      margin-bottom: 20px;
      font-size: 14px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .stat-item {
      display: flex;
      align-items: center;
    }
    
    .stat-number {
      font-size: 18px;
      font-weight: 500;
      margin-right: 5px;
      color: var(--primary);
    }
    
    .export-import {
      margin-top: 15px;
      padding-top: 15px;
      border-top: 1px dashed #ddd;
    }
    
    .function-btn {
      background-color: #6c757d;
      color: white;
      border: none;
      padding: 8px 12px;
      border-radius: 4px;
      margin-right: 5px;
      font-size: 12px;
      cursor: pointer;
    }
    
    @media (max-width: 768px) {
      .chat-container {
        margin: 0;
        border-radius: 0;
        height: 100vh;
        display: flex;
        flex-direction: column;
      }
      
      #chatbox {
        flex: 1;
        height: auto;
      }
      
      .message {
        max-width: 85%;
      }
    }
    
    .advanced-options {
      display: flex;
      gap: 10px;
      margin: 15px 0;
    }
    
    .toggle-switch {
      position: relative;
      display: inline-block;
      width: 50px;
      height: 24px;
    }
    
    .toggle-switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }
    
    .toggle-slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: #ccc;
      transition: .4s;
      border-radius: 24px;
    }
    
    .toggle-slider:before {
      position: absolute;
      content: "";
      height: 16px;
      width: 16px;
      left: 4px;
      bottom: 4px;
      background-color: white;
      transition: .4s;
      border-radius: 50%;
    }
    
    input:checked + .toggle-slider {
      background-color: var(--primary);
    }
    
    input:checked + .toggle-slider:before {
      transform: translateX(26px);
    }
    
    .option-label {
      display: flex;
      align-items: center;
      cursor: pointer;
    }
    
    .info-tooltip {
      position: relative;
      display: inline-block;
      margin-left: 5px;
      width: 16px;
      height: 16px;
      background-color: var(--gray);
      color: white;
      border-radius: 50%;
      text-align: center;
      line-height: 16px;
      font-size: 12px;
    }
    
    .info-tooltip:hover .tooltip-text {
      visibility: visible;
      opacity: 1;
    }
    
    .tooltip-text {
      visibility: hidden;
      width: 200px;
      background-color: var(--dark);
      color: white;
      text-align: center;
      border-radius: 6px;
      padding: 5px;
      position: absolute;
      z-index: 1;
      bottom: 125%;
      left: 50%;
      margin-left: -100px;
      opacity: 0;
      transition: opacity 0.3s;
      font-weight: normal;
      font-size: 12px;
    }
    
    .import-container {
      margin-top: 10px;
    }
    
    .file-input {
      width: 0.1px;
      height: 0.1px;
      opacity: 0;
      overflow: hidden;
      position: absolute;
      z-index: -1;
    }
    
    .file-label {
      display: inline-block;
      cursor: pointer;
      padding: 8px 12px;
      background-color: var(--gray);
      color: white;
      border-radius: 4px;
      font-size: 12px;
    }
    
    .progress-container {
      width: 100%;
      background-color: #f1f1f1;
      border-radius: 10px;
      margin: 15px 0;
    }
    
    .progress-bar {
      height: 10px;
      border-radius: 10px;
      background: linear-gradient(90deg, var(--primary) 0%, var(--success) 100%);
      width: 0%;
      transition: width 0.5s;
    }
    
    .memory-chip {
      display: inline-block;
      background-color: #e3f2fd;
      border-radius: 16px;
      padding: 3px 10px;
      margin: 3px;
      font-size: 12px;
      color: var(--primary-dark);
    }
    
    .memory-container {
      margin-top: 10px;
      border: 1px solid #e1e8ed;
      border-radius: 4px;
      padding: 10px;
      max-height: 100px;
      overflow-y: auto;
    }
    
    .loading {
      display: inline-block;
      width: 15px;
      height: 15px;
      border: 2px solid rgba(255,255,255,.3);
      border-radius: 50%;
      border-top-color: white;
      animation: spin 1s ease-in-out infinite;
      margin-left: 5px;
    }
    
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    
    .definition-source {
      font-size: 10px;
      opacity: 0.7;
      margin-top: 5px;
      font-style: italic;
    }
    
    /* Analytics specific styles */
    .analytics-container {
      padding: 15px 0;
    }
    
    .chart-container {
      margin-bottom: 25px;
    }
    
    .chart-title {
      font-size: 16px;
      font-weight: 500;
      margin-bottom: 10px;
      color: var(--text-primary);
    }
    
    .bar-chart {
      display: flex;
      height: 200px;
      margin-top: 20px;
      position: relative;
      border-bottom: 1px solid var(--border-color);
      border-left: 1px solid var(--border-color);
    }
    
    .chart-bar {
      flex: 1;
      margin: 0 5px;
      background: var(--chart-bar);
      align-self: flex-end;
      position: relative;
      min-width: 30px;
      border-top-left-radius: 4px;
      border-top-right-radius: 4px;
      transition: height 1s ease;
    }
    
    .chart-bar-label {
      position: absolute;
      bottom: -25px;
      left: 0;
      right: 0;
      text-align: center;
      font-size: 12px;
      color: var(--text-secondary);
    }
    
    .chart-value {
      position: absolute;
      top: -20px;
      left: 0;
      right: 0;
      text-align: center;
      font-size: 12px;
      color: var(--text-primary);
    }
    
    .analytics-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 20px;
      margin-top: 20px;
    }
    
    .stat-card {
      background-color: var(--bg-container);
      border: 1px solid var(--border-color);
      border-radius: 8px;
      padding: 15px;
      text-align: center;
    }
    
    .stat-number {
      font-size: 24px;
      font-weight: bold;
      color: var(--primary);
      margin: 10px 0;
    }
    
    .stat-label {
      font-size: 14px;
      color: var(--text-secondary);
    }
    
    .pie-chart {
      width: 150px;
      height: 150px;
      border-radius: 50%;
      background: conic-gradient(
        var(--primary) 0% var(--known-percent), 
        var(--danger) var(--known-percent) 100%
      );
      margin: 20px auto;
    }
    
    /* Advanced training specific styles */
    .slider-container {
      width: 100%;
      margin: 10px 0;
    }
    
    .slider {
      -webkit-appearance: none;
      appearance: none;
      width: 100%;
      height: 8px;
      border-radius: 4px;
      background: var(--bg-panel);
      outline: none;
    }
    
    .slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: var(--primary);
      cursor: pointer;
    }
    
    .slider-labels {
      display: flex;
      justify-content: space-between;
      margin-top: 5px;
      font-size: 12px;
      color: var(--text-secondary);
    }
    
    .personality-trait {
      margin-bottom: 15px;
    }
    
    .trait-name {
      font-weight: 500;
      margin-bottom: 5px;
    }
    
    .bulk-training-area {
      display: flex;
      flex-direction: column;
      gap: 15px;
    }
    
    .bulk-textarea {
      min-height: 150px;
      padding: 10px;
      border: 1px solid var(--border-color);
      border-radius: var(--border-radius);
      background-color: var(--bg-panel);
      color: var(--text-primary);
      font-size: 14px;
      resize: vertical;
    }
    
    .category-selector {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin: 10px 0;
    }
    
    .category-tag {
      padding: 5px 10px;
      border-radius: 15px;
      font-size: 12px;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .category-tag.selected {
      background-color: var(--primary);
      color: white;
    }
    
    .category-tag:not(.selected) {
      background-color: var(--bg-panel);
      color: var(--text-secondary);
    }
    
    .synonym-container {
      margin-top: 15px;
    }
    
    .synonym-group {
      border: 1px solid var(--border-color);
      border-radius: var(--border-radius);
      padding: 10px;
      margin-bottom: 10px;
    }
    
    .synonym-list {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin: 10px 0;
    }
    
    .synonym-chip {
      background-color: var(--bg-panel);
      border-radius: 15px;
      padding: 5px 10px;
      font-size: 12px;
      display: flex;
      align-items: center;
    }
    
    .remove-synonym {
      margin-left: 5px;
      cursor: pointer;
      font-size: 14px;
      color: var(--danger);
    }
    
    .add-synonym-form {
      display: flex;
      margin-top: 10px;
      gap: 10px;
    }
    
    .add-synonym-input {
      flex: 1;
      padding: 8px;
      border: 1px solid var (--border-color);
      border-radius: 4px;
      font-size: 12px;
    }
    
    .validation-message {
      color: var(--danger);
      font-size: 12px;
      margin-top: 5px;
    }
    
    .success-message {
      color: var (--success);
      font-size: 12px;
      margin-top: 5px;
    }
    
    .info-box {
      background-color: rgba(52, 152, 219, 0.1);
      border-left: 3px solid var(--primary);
      padding: 10px;
      margin: 15px 0;
      font-size: 14px;
    }
    
    .source-selector {
      margin: 10px 0;
      padding: 10px;
      border: 1px solid var(--border-color);
      border-radius: var(--border-radius);
      background-color: var(--bg-panel);
    }
    
    .source-option {
      margin: 8px 0;
    }
    
    .auto-training-info {
      margin-top: 15px;
      padding: 10px;
      border: 1px solid var (--border-color);
      border-radius: var(--border-radius);
      background-color: var(--bg-panel);
    }
    
    .auto-training-stats {
      margin-top: 10px;
      font-size: 12px;
    }
    
    .knowledge-source {
      display: inline-block;
      margin-right: 8px;
      padding: 2px 6px;
      border-radius: 12px;
      font-size: 10px;
      background-color: var(--primary);
      color: white;
    }
    
    .learning-event {
      padding: 8px;
      margin: 5px 0;
      border-left: 3px solid var(--primary);
      background-color: var(--bg-panel);
      font-size: 12px;
    }
    
    .learning-log {
      max-height: 150px;
      overflow-y: auto;
      margin-top: 10px;
    }
    
    .source-section {
      margin-top: 20px;
      padding: 15px;
      border: 1px solid var(--border-color);
      border-radius: var(--border-radius);
      background-color: var(--bg-panel);
    }
    
    .source-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 15px;
      margin-top: 10px;
    }
    
    .source-card {
      padding: 12px;
      border: 1px solid var(--border-color);
      border-radius: var(--border-radius);
      background-color: var(--bg-container);
    }
    
    .source-title {
      display: flex;
      align-items: center;
      font-weight: 500;
      margin-bottom: 8px;
    }
    
    .source-icon {
      display: inline-flex;
      width: 24px;
      height: 24px;
      background-color: var(--primary);
      border-radius: 50%;
      align-items: center;
      justify-content: center;
      color: white;
      margin-right: 8px;
      font-size: 12px;
    }
    
    .source-options {
      margin-top: 5px;
    }
    
    .source-option {
      display: flex;
      align-items: center;
      margin: 8px 0;
      font-size: 14px;
    }
    
    .source-option input[type="checkbox"] {
      margin-right: 8px;
    }
    
    .source-option input[type="range"] {
      width: 100%;
      margin-top: 5px;
    }
    
    .threshold-label {
      display: flex;
      justify-content: space-between;
      font-size: 12px;
      color: var(--text-secondary);
    }
    
    .advanced-source-toggle {
      margin-bottom: 15px;
    }
    
    .learning-mode-select {
      width: 100%;
      padding: 8px;
      margin-top: 5px;
      border: 1px solid var(--border-color);
      border-radius: 4px;
      background-color: var(--bg-panel);
      color: var(--text-primary);
    }
    
    .confidence-meter {
      height: 5px;
      width: 100%;
      background-color: #f1f1f1;
      border-radius: 2px;
      margin-top: 5px;
      position: relative;
      overflow: hidden;
    }
    
    .confidence-level {
      height: 100%;
      background: linear-gradient(90deg, #ff6b6b 0%, #ffdd59 50%, #1dd1a1 100%);
      border-radius: 2px;
      transition: width 0.3s;
    }
    
    .confidence-marker {
      position: absolute;
      top: -4px;
      width: 2px;
      height: 13px;
      background-color: #333;
    }
    
    .learning-stats-card {
      padding: 10px;
      border: 1px solid var(--border-color);
      border-radius: var(--border-radius);
      margin-top: 15px;
    }
    
    .learning-stat-row {
      display: flex;
      justify-content: space-between;
      margin: 8px 0;
    }
    
    .small-badge {
      display: inline-block;
      padding: 2px 6px;
      border-radius: 10px;
      font-size: 10px;
      background-color: var(--gray);
      color: white;
      margin-left: 5px;
    }
  </style>
</head>
<body>
  <div class="chat-container">
    <div class="chat-header">
      <div>
        <span class="chat-header-icon">ðŸ¤–</span>
        Learning Chatbot
      </div>
      <div class="chat-header-actions">
        <small id="trainingStatus"></small>
        <div class="theme-toggle" id="themeToggle">
          ðŸŒ“
        </div>
      </div>
    </div>
    <div id="chatbox">
      <!-- Chat messages will appear here -->
    </div>
    <div class="input-area">
      <input type="text" id="userInput" placeholder="Type a message...">
      <button id="sendBtn">Send</button>
    </div>
    <div class="help-text">
      Teach me using the format: train: question # answer or use the Training Panel below
    </div>
    
    <div class="training-toggle" id="trainingToggle">
      Show Training Panel
    </div>
    
    <div class="training-panel" id="trainingPanel">
      <div class="tab-container">
        <div class="tab active" data-tab="add">Add Training</div>
        <div class="tab" data-tab="words">Word Learning</div>
        <div class="tab" data-tab="advanced">Advanced</div>
        <div class="tab" data-tab="advtraining">Advanced Training</div>
        <div class="tab" data-tab="analytics">Analytics</div>
        <div class="tab" data-tab="view">View All Data</div>
      </div>
      
      <div class="training-stats" id="trainingStats">
        <!-- Training stats will appear here -->
      </div>
      
      <div class="tab-content" id="addTrainingTab">
        <h3>Train the Chatbot</h3>
        <div class="training-form">
          <input type="text" id="trainQuestion" placeholder="When I say this...">
          <textarea id="trainAnswer" placeholder="The chatbot should respond with..."></textarea>
          <button id="addTrainingBtn">Add Training</button>
        </div>
      </div>
      
      <div class="tab-content" id="wordsTrainingTab" style="display:none;">
        <h3>Teach Words & Meanings</h3>
        <div class="training-form">
          <input type="text" id="wordInput" placeholder="Word or phrase to learn">
          <textarea id="meaningInput" placeholder="Definition or meaning"></textarea>
          <button id="addWordBtn">Add Word</button>
        </div>
        
        <div class="help-text">
          The bot will remember these words and their meanings during conversations.
          Try asking "What does [word] mean?" or "Define [word]"
        </div>
      </div>
      
      <div class="tab-content" id="advancedTab" style="display:none;">
        <h3>Advanced Learning Settings</h3>
        
        <div class="advanced-options">
          <label class="option-label">
            <span class="toggle-switch">
              <input type="checkbox" id="onlineLookupToggle">
              <span class="toggle-slider"></span>
            </span>
            <span style="margin-left: 10px;">Online Dictionary Lookup</span>
            <span class="info-tooltip">?
              <span class="tooltip-text">When enabled, the bot will attempt to look up unknown words using an online dictionary API.</span>
            </span>
          </label>
          
          <label class="option-label">
            <span class="toggle-switch">
              <input type="checkbox" id="contextMemoryToggle" checked>
              <span class="toggle-slider"></span>
            </span>
            <span style="margin-left: 10px;">Context Memory</span>
            <span class="info-tooltip">?
              <span class="tooltip-text">Keeps track of conversation topics to provide more relevant responses.</span>
            </span>
          </label>
        </div>
        
        <h4>Bot Learning Progress</h4>
        <div class="progress-container">
          <div class="progress-bar" id="learningProgress"></div>
        </div>
        
        <h4>Context Memory</h4>
        <div class="memory-container" id="contextMemory">
          <!-- Context memory chips will appear here -->
        </div>
        
        <div class="import-container">
          <h4>Import Training Data</h4>
          <input type="file" id="importFile" class="file-input" accept=".json,.txt">
          <label for="importFile" class="file-label">Choose File</label>
          <span id="fileNameDisplay" style="margin-left: 10px; font-size: 12px;"></span>
          <button id="importBtn" class="function-btn" style="display: none;">Import</button>
        </div>
        
        <!-- Auto-Learning Section -->
        <h4>Auto-Learning Settings</h4>
        <div class="advanced-options">
          <label class="option-label">
            <span class="toggle-switch">
              <input type="checkbox" id="autoLearnToggle" checked>
              <span class="toggle-slider"></span>
            </span>
            <span style="margin-left: 10px;">Auto-Learn from Conversations</span>
            <span class="info-tooltip">?
              <span class="tooltip-text">Automatically save your exchanges as training data.</span>
            </span>
          </label>
        </div>
        
        <div class="source-selector">
          <h4>Knowledge Sources</h4>
          <p>Select sources for expanding the bot's knowledge:</p>
          <div class="source-option">
            <input type="checkbox" id="useConversationsSource" checked>
            <label for="useConversationsSource">Previous conversations</label>
          </div>
          <div class="source-option">
            <input type="checkbox" id="useOnlineSource" checked>
            <label for="useOnlineSource">Online dictionary</label>
          </div>
        </div>
        
        <div class="auto-training-info">
          <h4>Auto-Learning Status</h4>
          <div class="auto-training-stats">
            <div><span class="knowledge-source">Conversations</span> <span id="conversationLearned">0</span> patterns learned</div>
            <div><span class="knowledge-source">Words</span> <span id="wordsLearned">0</span> definitions learned</div>
          </div>
          <h5>Recent Learning Events</h5>
          <div class="learning-log" id="learningLog">
            <!-- Learning events will appear here -->
          </div>
        </div>
      </div>
      
      <!-- Advanced Training Tab -->
      <div class="tab-content" id="advtrainingTab" style="display:none;">
        <h3>Advanced Training Tools</h3>
        
        <div class="info-box">
          These tools provide more sophisticated ways to train the chatbot, including bulk training, personality adjustment, and synonym recognition.
        </div>
        
        <h4>Personality Configuration</h4>
        <p>Adjust the bot's personality traits to influence its response style:</p>
        
        <div class="personality-trait">
          <div class="trait-name">Formality</div>
          <div class="slider-container">
            <input type="range" min="0" max="100" value="50" class="slider" id="formalitySlider">
            <div class="slider-labels">
              <span>Casual</span>
              <span>Formal</span>
            </div>
          </div>
        </div>
        
        <div class="personality-trait">
          <div class="trait-name">Verbosity</div>
          <div class="slider-container">
            <input type="range" min="0" max="100" value="50" class="slider" id="verbositySlider">
            <div class="slider-labels">
              <span>Concise</span>
              <span>Detailed</span>
            </div>
          </div>
        </div>
        
        <div class="personality-trait">
          <div class="trait-name">Empathy</div>
          <div class="slider-container">
            <input type="range" min="0" max="100" value="70" class="slider" id="empathySlider">
            <div class="slider-labels">
              <span>Factual</span>
              <span>Empathetic</span>
            </div>
          </div>
        </div>
        
        <button id="savePersonalityBtn" class="function-btn">Save Personality Settings</button>
        
        <h4>Bulk Training</h4>
        <p>Train multiple conversations at once using the format: "Q: question | A: answer" (one per line)</p>
        
        <div class="bulk-training-area">
          <select id="bulkCategory" class="add-synonym-input">
            <option value="">-- Select Category --</option>
            <option value="general">General</option>
            <option value="technical">Technical</option>
            <option value="casual">Casual Conversation</option>
            <option value="customer_service">Customer Service</option>
            <option value="custom">Custom Category</option>
          </select>
          
          <input type="text" id="customCategory" placeholder="Custom category name" class="add-synonym-input" style="display:none;">
          
          <textarea id="bulkTraining" class="bulk-textarea" placeholder="Q: How's the weather today? | A: I don't have access to real-time weather data, but I hope it's nice where you are!
Q: What do you think about AI? | A: AI is a fascinating field with both promising opportunities and challenges to consider."></textarea>
          
          <button id="processBulkBtn" class="function-btn">Process Bulk Training</button>
          <div id="bulkResult" class="success-message"></div>
        </div>
        
        <h4>Synonym Recognition</h4>
        <p>Create groups of words or phrases that should be treated as equivalent:</p>
        
        <div class="synonym-container" id="synonymContainer">
          <!-- Synonym groups will be added here dynamically -->
        </div>
        
        <div class="synonym-form">
          <input type="text" id="newSynonymGroup" placeholder="Group name (e.g. 'greetings')" class="add-synonym-input">
          <button id="addSynonymGroupBtn" class="function-btn">Add Group</button>
        </div>
        
        <!-- New Advanced Sources Section -->
        <h4>Advanced Sources</h4>
        <div class="source-section">
          <div class="advanced-source-toggle">
            <label class="option-label">
              <span class="toggle-switch">
                <input type="checkbox" id="advancedSourceToggle" checked>
                <span class="toggle-slider"></span>
              </span>
              <span style="margin-left: 10px;">Enable Advanced Sources</span>
              <span class="info-tooltip">?
                <span class="tooltip-text">When enabled, the chatbot will use multiple sources for learning and generating responses.</span>
              </span>
            </label>
          </div>
          
          <p>Configure where the chatbot should source information from and how it should learn:</p>
          
          <div class="source-grid">
            <div class="source-card">
              <div class="source-title">
                <div class="source-icon">ðŸ“š</div>
                Dictionary Sources
              </div>
              <div class="source-options">
                <div class="source-option">
                  <input type="checkbox" id="localDictionarySource" checked>
                  <label for="localDictionarySource">Local dictionary</label>
                </div>
                <div class="source-option">
                  <input type="checkbox" id="onlineDictionarySource" checked>
                  <label for="onlineDictionarySource">Online dictionary API</label>
                </div>
                <div class="source-option">
                  <input type="checkbox" id="userDefinitionsSource" checked>
                  <label for="userDefinitionsSource">User-provided definitions</label>
                </div>
              </div>
            </div>
            
            <div class="source-card">
              <div class="source-title">
                <div class="source-icon">ðŸ’¬</div>
                Conversation Sources
              </div>
              <div class="source-options">
                <div class="source-option">
                  <input type="checkbox" id="pretrainedSource" checked>
                  <label for="pretrainedSource">Pre-trained responses</label>
                </div>
                <div class="source-option">
                  <input type="checkbox" id="userTrainingSource" checked>
                  <label for="userTrainingSource">User training data</label>
                </div>
                <div class="source-option">
                  <input type="checkbox" id="inferredSource" checked>
                  <label for="inferredSource">Inferred from conversations</label>
                </div>
              </div>
            </div>
            
            <div class="source-card">
              <div class="source-title">
                <div class="source-icon">ðŸ§ </div>
                Learning Settings
              </div>
              <div class="source-options">
                <div class="source-option">
                  <label for="learningMode">Learning Mode:</label>
                  <select id="learningMode" class="learning-mode-select">
                    <option value="conservative">Conservative - Learn only from explicit training</option>
                    <option value="balanced" selected>Balanced - Learn from training and some conversations</option>
                    <option value="aggressive">Aggressive - Learn from all interactions</option>
                  </select>
                </div>
                <div class="source-option">
                  <label for="confidenceThreshold">Confidence Threshold:</label>
                  <input type="range" id="confidenceThreshold" min="0" max="100" value="70">
                  <div class="threshold-label">
                    <span>Low</span>
                    <span>High</span>
                  </div>
                  <div class="confidence-meter">
                    <div class="confidence-level" style="width: 100%"></div>
                    <div class="confidence-marker" style="left: 70%"></div>
                  </div>
                </div>
              </div>
            </div>
            
            <div class="source-card">
              <div class="source-title">
                <div class="source-icon">ðŸ“Š</div>
                Self-Learning Stats
              </div>
              <div class="learning-stats-card">
                <div class="learning-stat-row">
                  <span>Auto-learned patterns:</span>
                  <span id="autoLearnedCount">0</span>
                </div>
                <div class="learning-stat-row">
                  <span>Confidence threshold:</span>
                  <span id="confidenceDisplay">70%</span>
                </div>
                <div class="learning-stat-row">
                  <span>Learning mode:</span>
                  <span id="learningModeDisplay">Balanced</span>
                </div>
                <div class="learning-stat-row">
                  <span>Active sources:</span>
                  <span id="activeSourcesDisplay">
                    <span class="small-badge">Local</span>
                    <span class="small-badge">Online</span>
                    <span class="small-badge">User</span>
                  </span>
                </div>
              </div>
            </div>
          </div>
          
          <button id="saveSourcesBtn" class="function-btn" style="margin-top: 15px;">Save Source Settings</button>
        </div>
      </div>
      
      <div class="tab-content" id="analyticsTab" style="display:none;">
        <h3>Performance Analytics</h3>
        
        <div class="analytics-grid">
          <div class="stat-card">
            <div class="stat-label">Response Rate</div>
            <div class="stat-number" id="responseRate">0%</div>
            <div class="stat-desc">Successfully answered queries</div>
          </div>
          
          <div class="stat-card">
            <div class="stat-label">Learning Rate</div>
            <div class="stat-number" id="learningRate">0</div>
            <div class="stat-desc">New patterns per 10 messages</div>
          </div>
          
          <div class="stat-card">
            <div class="stat-label">Total Interactions</div>
            <div class="stat-number" id="totalInteractions">0</div>
          </div>
          
          <div class="stat-card">
            <div class="stat-label">Knowledge Distribution</div>
            <div class="pie-chart" id="knowledgePie" style="--known-percent: 30%"></div>
            <div class="stat-desc">
              <span style="color:var(--primary)">â– </span> Known
              <span style="color:var(--danger)">â– </span> Unknown
            </div>
          </div>
        </div>
        
        <div class="chart-container">
          <div class="chart-title">Learning Progress</div>
          <div class="bar-chart" id="learningChart">
            <!-- Chart bars will be added dynamically -->
          </div>
        </div>
        
        <div class="chart-container">
          <div class="chart-title">Most Used Responses</div>
          <div class="bar-chart" id="responsesChart">
            <!-- Chart bars will be added dynamically -->
          </div>
        </div>
      </div>
      
      <div class="tab-content" id="viewTrainingTab" style="display:none;">
        <h3>Conversation Training Data</h3>
        <div class="trained-items" id="trainedItems">
          <!-- Training items will be listed here -->
        </div>
        
        <h3>Learned Words</h3>
        <div class="trained-items" id="learnedWords">
          <!-- Words will be listed here -->
        </div>
        
        <div class="export-import">
          <button id="exportBtn" class="function-btn">Export Training Data</button>
          <button id="clearBtn" class="function-btn">Clear All Training</button>
        </div>
      </div>
    </div>
  </div>
  <script>
    // Initialize analytics data
    var analyticsData = JSON.parse(localStorage.getItem('chatbotAnalytics')) || {
      totalInteractions: 0,
      successfulResponses: 0,
      failedResponses: 0,
      learningEvents: 0,
      responseHistory: [],
      patternUsage: {}
    };
    
    // Save analytics data
    function saveAnalytics() {
      localStorage.setItem('chatbotAnalytics', JSON.stringify(analyticsData));
    }
    
    // Initialize training data storage with localStorage persistence or use defaults
    var trainingData = JSON.parse(localStorage.getItem('chatbotTraining'));
    var wordMeanings = JSON.parse(localStorage.getItem('chatbotWords'));
    
    // Default training data if none exists
    if (!trainingData) {
      trainingData = {
        "hello": "Hi there! How can I help you today?",
        "hi": "Hello! What can I do for you?",
        "how are you": "I'm doing well, thank you for asking! How are you?",
        "what can you do": "I can have conversations and learn new things. You can teach me responses and word definitions!",
        "what's your name": "I'm a learning chatbot. You can call me ChatBot!",
        "who are you": "I'm a learning chatbot created to have conversations and learn from our interactions.",
        "what time is it": "I don't have access to the current time. I'm a simple learning chatbot.",
        "tell me a joke": "Why don't scientists trust atoms? Because they make up everything!",
        "tell me another joke": "What do you call a fake noodle? An impasta!",
        "how do you learn": "I learn when you teach me using 'train: question # answer' format or through the training panel!",
        "goodbye": "Goodbye! Have a great day!",
        "bye": "Bye! Feel free to chat again anytime!",
        "thanks": "You're welcome!",
        "thank you": "You're welcome! Is there anything else I can help with?",
        "what's the weather": "I don't have access to weather information. I'm a simple chatbot that can learn from our conversations.",
        "help": "I can chat with you and learn new things! Teach me using 'train: question # answer' format or use the Training Panel below."
      };
      saveTrainingData();
    }
    
    if (!wordMeanings) {
      wordMeanings = {
        "chatbot": "A computer program designed to simulate conversation with human users, especially over the internet.",
        "ai": "Artificial Intelligence - the simulation of human intelligence processes by machines, especially computer systems.",
        "machine learning": "A subset of artificial intelligence that provides systems the ability to automatically learn and improve from experience.",
        "algorithm": "A process or set of rules to be followed in calculations or other problem-solving operations, especially by a computer.",
        "javascript": "A programming language commonly used to create interactive effects within web browsers.",
        "html": "HyperText Markup Language, the standard markup language for documents designed to be displayed in a web browser."
      };
      saveWordMeanings();
    }
    
    // Conversation context to track recent exchanges
    var conversationHistory = [];
    var maxHistoryLength = 5;
    
    function addMessage(sender, text) {
      var chatbox = document.getElementById('chatbox');
      var message = document.createElement('div');
      
      // Create message with better styling
      message.className = 'message ' + (sender === 'User' ? 'user-message' : 'bot-message');
      
      var senderSpan = document.createElement('div');
      senderSpan.className = 'message-info ' + (sender === 'User' ? 'user-info' : 'bot-info');
      senderSpan.textContent = sender;
      
      var textDiv = document.createElement('div');
      textDiv.textContent = text;
      
      message.appendChild(senderSpan);
      message.appendChild(textDiv);
      
      chatbox.appendChild(message);
      chatbox.scrollTop = chatbox.scrollHeight;
    }
    
    // Save training data to localStorage
    function saveTrainingData() {
      localStorage.setItem('chatbotTraining', JSON.stringify(trainingData));
    }
    
    // New function to save word meanings
    function saveWordMeanings() {
      localStorage.setItem('chatbotWords', JSON.stringify(wordMeanings));
    }
    
    // Function to process training
    function trainBot(message) {
      // Remove "train:" prefix and split using "#"
      var trainingContent = message.substring(6).trim();
      var parts = trainingContent.split("#");
      if(parts.length >= 2) {
         var question = parts[0].trim();
         var answer = parts.slice(1).join("#").trim();
         trainingData[question.toLowerCase()] = answer;
         saveTrainingData();
         return "Training successful.";
      } else {
         return "Training format incorrect. Use 'train: question # answer'";
      }
    }
    
    // Helper function to find similarity between strings
    function stringSimilarity(s1, s2) {
      s1 = s1.toLowerCase();
      s2 = s2.toLowerCase();
      
      // Simple word overlap calculation
      const words1 = s1.split(/\s+/);
      const words2 = s2.split(/\s+/);
      let matches = 0;
      
      words1.forEach(w1 => {
        if (words2.includes(w1)) matches++;
      });
      
      return matches / Math.max(words1.length, words2.length);
    }
    
    // Find best matching question in training data
    function findBestMatch(message) {
      let bestMatch = null;
      let highestSimilarity = 0.5; // Threshold for considering a match
      
      Object.keys(trainingData).forEach(question => {
        const similarity = stringSimilarity(message, question);
        if (similarity > highestSimilarity) {
          highestSimilarity = similarity;
          bestMatch = question;
        }
      });
      
      return bestMatch;
    }
    
    // Learn from conversation patterns
    function learnFromConversation() {
      if (conversationHistory.length < 2) return;
      
      const lastUserMsg = conversationHistory[conversationHistory.length - 2];
      const lastBotMsg = conversationHistory[conversationHistory.length - 1];
      
      if (lastUserMsg.sender === 'User' && lastBotMsg.sender === 'Bot' && 
          lastBotMsg.text !== "I don't understand that yet.") {
        // Learn simple patterns when bot gives specific answers
        const userMsgLower = lastUserMsg.text.toLowerCase();
        if (!trainingData.hasOwnProperty(userMsgLower)) {
          trainingData[userMsgLower] = lastBotMsg.text;
          saveTrainingData();
        }
      }
    }
    
    // Update training stats display
    function updateTrainingStats() {
      const statsElem = document.getElementById('trainingStats');
      const conversationCount = Object.keys(trainingData).length;
      const wordCount = Object.keys(wordMeanings).length;
      
      statsElem.innerHTML = `
        <div class="stat-item">
          <div class="stat-number">${conversationCount}</div>
          <div>Conversation Patterns</div>
        </div>
        <div class="stat-item">
          <div class="stat-number">${wordCount}</div>
          <div>Word Definitions</div>
        </div>
      `;
      
      updateHeaderStatus();
    }
    
    // Find word definitions in a message
    function checkForWordDefinitions(message) {
      const lowerMsg = message.toLowerCase();
      
      // Check for definition queries
      if(lowerMsg.startsWith("what does") || lowerMsg.startsWith("what is") || 
         lowerMsg.startsWith("define") || lowerMsg.includes("meaning of")) {
        
        // Extract the word being asked about
        let word = "";
        if(lowerMsg.includes("mean")) {
          word = lowerMsg.split("mean")[0].trim();
          word = word.replace(/what does|what is|the|meaning of/g, "").trim();
          if(word.endsWith("'s")) word = word.slice(0, -2);
        } else if(lowerMsg.startsWith("define")) {
          word = lowerMsg.replace("define", "").trim();
        } else if(lowerMsg.includes("meaning of")) {
          word = lowerMsg.split("meaning of")[1].trim();
        }
        
        // Check if we know this word
        if(word && wordMeanings.hasOwnProperty(word)) {
          return `"${word}" means: ${wordMeanings[word]}`;
        } else if(word) {
          return `I don't know what "${word}" means yet. You can teach me!`;
        }
      }
      
      // Look for known words in the message
      const words = lowerMsg.split(/\W+/);
      const knownWords = words.filter(w => w && wordMeanings.hasOwnProperty(w));
      
      if(knownWords.length > 0) {
        // Randomly decide to explain a word (20% chance)
        if(Math.random() < 0.2) {
          const randomWord = knownWords[Math.floor(Math.random() * knownWords.length)];
          return null; // Just recognize the word but don't interrupt with definition
        }
      }
      
      return null;
    }
    
    // Modified botResponse function with word learning capabilities
    async function botResponse(message) {
      var lowerMsg = message.toLowerCase();
      
      if(lowerMsg.startsWith("train:")) {
        return trainBot(message);
      }
      
      if(lowerMsg.startsWith("forget:")) {
        var key = lowerMsg.substring(7).trim();
        if(trainingData.hasOwnProperty(key)) {
          delete trainingData[key];
          saveTrainingData();
          return "Forgot about: " + key;
        } else if(wordMeanings.hasOwnProperty(key)) {
          delete wordMeanings[key];
          saveWordMeanings();
          return "Forgot the definition of: " + key;
        }
        return "I don't know anything about that.";
      }
      
      // Update context memory
      updateContext(message);
      
      // Check if asking for a word definition
      const wordDefinition = checkForWordDefinitions(message);
      if(wordDefinition) {
        return wordDefinition;
      }
      
      // Direct match in training data
      if(trainingData.hasOwnProperty(lowerMsg)) {
        return trainingData[lowerMsg];
      }
      
      // Try to find a similar question
      const bestMatch = findBestMatch(lowerMsg);
      if(bestMatch) {
        return trainingData[bestMatch];
      }
      
      // Try to find a word in the message to define if it looks like a definition request
      if(lowerMsg.includes("what") || lowerMsg.includes("define") || lowerMsg.includes("meaning")) {
        // Extract potential word to define (simple approach)
        const words = lowerMsg.split(/\W+/).filter(w => w.length > 3);
        
        // Try each word
        for(const word of words) {
          // Skip common question words
          if(['what', 'when', 'where', 'define', 'meaning', 'means', 'know', 'tell'].includes(word))
            continue;
            
          // Add loading indicator
          addMessage("Bot", "Let me look that up for you...");
          
          // Try to fetch definition
          const onlineDefinition = await fetchDefinition(word);
          
          if(onlineDefinition) {
            // Update UI to remove the loading message
            document.getElementById('chatbox').lastChild.remove();
            
            // Add the word to our known words
            wordMeanings[word] = onlineDefinition.definition;
            saveWordMeanings();
            
            return `"${word}" means: ${onlineDefinition.definition}\n\n<div class="definition-source">Source: ${onlineDefinition.source}</div>`;
          }
          
          // If we tried a lookup but failed, remove the loading message
          document.getElementById('chatbox').lastChild.remove();
        }
      }
      
      // Basic predefined responses
      if(lowerMsg.includes("hi") || lowerMsg.includes("hello")) {
        return "Hello! How can I help you today?";
      } else if(lowerMsg.includes("how are you")) {
        return "I'm a bot, so I'm always good.";
      } else if(lowerMsg.includes("bye")) {
        return "Goodbye!";
      } else {
        return "I don't understand that yet.";
      }
    }
    
    document.getElementById('sendBtn').addEventListener('click', async function() {
      var input = document.getElementById('userInput');
      var userText = input.value.trim();
      if(userText !== "") {
        addMessage("User", userText);
        // Add to conversation history
        conversationHistory.push({ sender: 'User', text: userText });
        
        // Clear input immediately for better UX
        input.value = "";
        
        // Handle potential async response
        var response = await botResponse(userText);
        
        // For HTML content in responses (like definition sources)
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = response;
        const plainText = tempDiv.textContent || tempDiv.innerText;
        
        addMessage("Bot", response);
        // Add to conversation history (only the text part)
        conversationHistory.push({ sender: 'Bot', text: plainText });
        
        // Track this interaction
        trackInteraction(userText, plainText);
        
        // Trim conversation history
        if(conversationHistory.length > maxHistoryLength * 2) {
          conversationHistory = conversationHistory.slice(-maxHistoryLength * 2);
        }
        
        // Try to learn from this exchange
        learnFromConversation();
      }
    });
    
    document.getElementById('userInput').addEventListener('keypress', function(e) {
      if(e.key === 'Enter'){
        document.getElementById('sendBtn').click();
      }
    });
    
    // Training Panel Functionality
    document.getElementById('trainingToggle').addEventListener('click', function() {
      var panel = document.getElementById('trainingPanel');
      var isVisible = panel.style.display === 'block';
      
      panel.style.display = isVisible ? 'none' : 'block';
      this.textContent = isVisible ? 'Show Training Panel' : 'Hide Training Panel';
      
      if(!isVisible) {
        updateTrainingList();
        updateWordsList();
        updateTrainingStats();
      }
    });
    
    // Tab switching functionality
    document.querySelectorAll('.tab').forEach(tab => {
      tab.addEventListener('click', function() {
        // Make all tabs inactive
        document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
        // Make clicked tab active
        this.classList.add('active');
        
        const tabId = this.getAttribute('data-tab');
        
        // Hide all tab contents
        document.querySelectorAll('.tab-content').forEach(content => {
          content.style.display = 'none';
        });
        
        // Show selected tab content
        if(tabId === 'add') {
          document.getElementById('addTrainingTab').style.display = 'block';
        } else if(tabId === 'words') {
          document.getElementById('wordsTrainingTab').style.display = 'block';
        } else if(tabId === 'advanced') {
          document.getElementById('advancedTab').style.display = 'block';
          updateLearningProgress();
          updateContextMemory();
        } else if(tabId === 'analytics') {
          document.getElementById('analyticsTab').style.display = 'block';
          updateAnalytics();
        } else if(tabId === 'view') {
          document.getElementById('viewTrainingTab').style.display = 'block';
          updateTrainingList();
          updateWordsList();
        } else if(tabId === 'advtraining') {
          document.getElementById('advtrainingTab').style.display = 'block';
          initPersonalitySliders();
          updateSynonymUI();
        }
        
        updateTrainingStats();
      });
    });
    
    // Add new training from the panel
    document.getElementById('addTrainingBtn').addEventListener('click', function() {
      const question = document.getElementById('trainQuestion').value.trim();
      const answer = document.getElementById('trainAnswer').value.trim();
      
      if(question && answer) {
        trainingData[question.toLowerCase()] = answer;
        saveTrainingData();
        
        // Clear the form
        document.getElementById('trainQuestion').value = '';
        document.getElementById('trainAnswer').value = '';
        
        // Show success message
        addMessage('Bot', `I've learned to respond to "${question}" with "${answer}"`);
        updateTrainingList();
      } else {
        addMessage('Bot', 'Please provide both a question and an answer for training.');
      }
    });
    
    // Add word definition learning
    document.getElementById('addWordBtn').addEventListener('click', function() {
      const word = document.getElementById('wordInput').value.trim().toLowerCase();
      const meaning = document.getElementById('meaningInput').value.trim();
      
      if(word && meaning) {
        wordMeanings[word] = meaning;
        saveWordMeanings();
        
        // Clear the form
        document.getElementById('wordInput').value = '';
        document.getElementById('meaningInput').value = '';
        
        // Show success message
        addMessage('Bot', `I've learned that "${word}" means: ${meaning}`);
        updateWordsList();
        updateTrainingStats();
      } else {
        addMessage('Bot', 'Please provide both a word and its meaning.');
      }
    });
    
    // Update the list of trained items
    function updateTrainingList() {
      const container = document.getElementById('trainedItems');
      container.innerHTML = '';
      
      const keys = Object.keys(trainingData);
      if(keys.length === 0) {
        container.innerHTML = '<div class="trained-item">No training data yet</div>';
        return;
      }
      
      keys.sort().forEach(key => {
        const item = document.createElement('div');
        item.className = 'trained-item';
        
        const text = document.createElement('div');
        text.textContent = `Q: "${key}" â†’ A: "${trainingData[key]}"`;
        
        const deleteBtn = document.createElement('span');
        deleteBtn.className = 'delete-trained';
        deleteBtn.textContent = 'Ã—';
        deleteBtn.setAttribute('data-key', key);
        deleteBtn.addEventListener('click', function() {
          const keyToDelete = this.getAttribute('data-key');
          delete trainingData[keyToDelete];
          saveTrainingData();
          updateTrainingList();
        });
        
        item.appendChild(text);
        item.appendChild(deleteBtn);
        container.appendChild(item);
      });
    }
    
    // Update the list of learned words
    function updateWordsList() {
      const container = document.getElementById('learnedWords');
      container.innerHTML = '';
      
      const words = Object.keys(wordMeanings);
      if(words.length === 0) {
        container.innerHTML = '<div class="trained-item">No words learned yet</div>';
        return;
      }
      
      words.sort().forEach(word => {
        const item = document.createElement('div');
        item.className = 'trained-item';
        
        const text = document.createElement('div');
        text.innerHTML = `<span class="word-chip">${word}</span> <span class="meaning-text">${wordMeanings[word]}</span>`;
        
        const deleteBtn = document.createElement('span');
        deleteBtn.className = 'delete-trained';
        deleteBtn.textContent = 'Ã—';
        deleteBtn.setAttribute('data-word', word);
        deleteBtn.addEventListener('click', function() {
          const wordToDelete = this.getAttribute('data-word');
          delete wordMeanings[wordToDelete];
          saveWordMeanings();
          updateWordsList();
          updateTrainingStats();
        });
        
        item.appendChild(text);
        item.appendChild(deleteBtn);
        container.appendChild(item);
      });
    }
    
    // Export training data
    document.getElementById('exportBtn').addEventListener('click', function() {
      const exportData = {
        conversations: trainingData,
        words: wordMeanings
      };
      
      const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(exportData));
      const downloadAnchor = document.createElement('a');
      downloadAnchor.setAttribute("href", dataStr);
      downloadAnchor.setAttribute("download", "chatbot_training.json");
      document.body.appendChild(downloadAnchor);
      downloadAnchor.click();
      document.body.removeChild(downloadAnchor);
    });
    
    // Clear all training
    document.getElementById('clearBtn').addEventListener('click', function() {
      if(confirm("Are you sure you want to clear all training data? This cannot be undone!")) {
        trainingData = {};
        wordMeanings = {};
        saveTrainingData();
        saveWordMeanings();
        updateTrainingList();
        updateWordsList();
        updateTrainingStats();
        addMessage('Bot', 'All training data has been cleared.');
      }
    });
    
    // Update training status in header
    function updateHeaderStatus() {
      const conversationCount = Object.keys(trainingData).length;
      const wordCount = Object.keys(wordMeanings).length;
      document.getElementById('trainingStatus').textContent = 
        `${conversationCount} patterns | ${wordCount} words`;
    }
    
    // Show initial message when page loads
    window.onload = function() {
      addMessage("Bot", "Hello! I'm a learning chatbot. I already know some responses, but you can teach me more!");
      updateTrainingStats();
      updateWordsList();
      updateTrainingList();
      updateHeaderStatus();
      updateLearningProgress();
      updateContextMemory();
      updateAnalytics();
    };
    
    // Initialize context memory
    var contextMemory = [];
    var maxContextItems = 10;
    
    // Update the learning progress bar
    function updateLearningProgress() {
      // Calculate a score based on training data size and complexity
      const conversationCount = Object.keys(trainingData).length;
      const wordCount = Object.keys(wordMeanings).length;
      
      // Max expected values for a "complete" training
      const maxConversations = 100;
      const maxWords = 50;
      
      // Calculate percentage (capped at 100%)
      let percentage = ((conversationCount / maxConversations) * 0.7 + 
                        (wordCount / maxWords) * 0.3) * 100;
      percentage = Math.min(percentage, 100);
      
      document.getElementById('learningProgress').style.width = percentage + '%';
    }
    
    // Update context memory display
    function updateContextMemory() {
      const container = document.getElementById('contextMemory');
      container.innerHTML = '';
      
      if(contextMemory.length === 0) {
        container.innerHTML = '<em>No active context memory</em>';
        return;
      }
      
      contextMemory.forEach(item => {
        const chip = document.createElement('div');
        chip.className = 'memory-chip';
        chip.textContent = item;
        container.appendChild(chip);
      });
    }
    
    // Extract key topics from a message
    function extractTopics(message) {
      // Simple extraction: get words longer than 3 chars that aren't common words
      const commonWords = ['the', 'and', 'that', 'this', 'with', 'for', 'are', 'was', 'what', 'when', 'where', 'why', 'how'];
      const words = message.toLowerCase().split(/\W+/);
      
      return words.filter(word => 
        word.length > 3 && 
        !commonWords.includes(word) &&
        !contextMemory.includes(word)
      ).slice(0, 2); // Just take top 2 words
    }
    
    // Update context with new topics
    function updateContext(message) {
      if (!document.getElementById('contextMemoryToggle').checked)
        return;
        
      const newTopics = extractTopics(message);
      
      // Add new topics to context memory
      contextMemory = [...contextMemory, ...newTopics].slice(-maxContextItems);
      
      updateContextMemory();
    }
    
    // Fetch definition from API
    async function fetchDefinition(word) {
      if (!document.getElementById('onlineLookupToggle').checked)
        return null;
      
      try {
        const response = await fetch(`https://api.dictionaryapi.dev/api/v2/entries/en/${word}`);
        if(!response.ok) return null;
        
        const data = await response.json();
        
        if(data && data.length > 0 && data[0].meanings && data[0].meanings.length > 0) {
          // Get first definition
          const definition = data[0].meanings[0].definitions[0].definition;
          return {
            definition: definition,
            source: "Free Dictionary API"
          };
        }
      } catch(e) {
        console.error("Error fetching definition:", e);
      }
      
      return null;
    }
    
    // File upload handling
    document.getElementById('importFile').addEventListener('change', function(e) {
      const fileName = e.target.files[0]?.name || '';
      document.getElementById('fileNameDisplay').textContent = fileName;
      
      if(fileName) {
        document.getElementById('importBtn').style.display = 'inline-block';
      } else {
        document.getElementById('importBtn').style.display = 'none';
      }
    });
    
    document.getElementById('importBtn').addEventListener('click', function() {
      const fileInput = document.getElementById('importFile');
      const file = fileInput.files[0];
      
      if(!file) return;
      
      const reader = new FileReader();
      reader.onload = function(e) {
        try {
          const data = JSON.parse(e.target.result);
          
          // Import conversation data
          if(data.conversations) {
            trainingData = {...trainingData, ...data.conversations};
            saveTrainingData();
          }
          
          // Import word data
          if(data.words) {
            wordMeanings = {...wordMeanings, ...data.words};
            saveWordMeanings();
          }
          
          // Update UI
          updateTrainingList();
          updateWordsList();
          updateTrainingStats();
          updateLearningProgress();
          
          addMessage('Bot', `Import successful! Added ${
            Object.keys(data.conversations || {}).length
          } conversations and ${
            Object.keys(data.words || {}).length
          } word definitions.`);
          
        } catch(err) {
          addMessage('Bot', 'Error importing data. Make sure the file is in the correct JSON format.');
          console.error("Import error:", err);
        }
      };
      
      reader.readAsText(file);
    });
    
    // Check for saved theme preference or default to light
    const savedTheme = localStorage.getItem('chatbotTheme') || 'light';
    document.body.setAttribute('data-theme', savedTheme);
    
    // Theme toggle functionality
    document.getElementById('themeToggle').addEventListener('click', function() {
      const currentTheme = document.body.getAttribute('data-theme');
      const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
      
      document.body.setAttribute('data-theme', newTheme);
      localStorage.setItem('chatbotTheme', newTheme);
    });
    
    // Update analytics displays
    function updateAnalytics() {
      // Calculate response rate
      const totalQueries = analyticsData.successfulResponses + analyticsData.failedResponses;
      const responseRate = totalQueries > 0 
        ? Math.round((analyticsData.successfulResponses / totalQueries) * 100) 
        : 0;
      
      // Calculate learning rate (new patterns per 10 messages)
      const learningRate = totalQueries > 0 
        ? (analyticsData.learningEvents / totalQueries * 10).toFixed(1) 
        : 0;
      
      // Update stat displays
      document.getElementById('responseRate').textContent = responseRate + '%';
      document.getElementById('learningRate').textContent = learningRate;
      document.getElementById('totalInteractions').textContent = analyticsData.totalInteractions;
      
      // Update knowledge distribution pie chart
      const knownPercent = Object.keys(trainingData).length + Object.keys(wordMeanings).length;
      const knownPercentage = Math.min(knownPercent / 2, 100); // Scale for visualization
      document.getElementById('knowledgePie').style.setProperty('--known-percent', `${knownPercentage}%`);
      
      // Create bar charts
      createLearningChart();
      createResponseUsageChart();
    }
    
    // Create learning progress chart
    function createLearningChart() {
      const chartContainer = document.getElementById('learningChart');
      chartContainer.innerHTML = '';
      
      // Get last 7 days of data (or less if not enough)
      const today = new Date();
      const days = [];
      
      // Generate last 7 days
      for (let i = 6; i >= 0; i--) {
        const date = new Date(today);
        date.setDate(today.getDate() - i);
        const dayStr = date.toLocaleDateString('en-US', { weekday: 'short' });
        days.push({
          label: dayStr,
          date: date.toISOString().split('T')[0],
          count: 0
        });
      }
      
      // Count learning events per day from response history
      analyticsData.responseHistory.forEach(item => {
        if (item.learned) {
          const day = item.timestamp.split('T')[0];
          const dayObj = days.find(d => d.date === day);
          if (dayObj) dayObj.count++;
        }
      });
      
      // Find max for scaling
      const maxCount = Math.max(...days.map(d => d.count));
      
      // Create bars
      days.forEach(day => {
        const barHeight = maxCount > 0 ? (day.count / maxCount * 100) : 0;
        
        const bar = document.createElement('div');
        bar.className = 'chart-bar';
        bar.style.height = `${Math.max(barHeight, 5)}%`;
        
        const label = document.createElement('div');
        label.className = 'chart-bar-label';
        label.textContent = day.label;
        
        const value = document.createElement('div');
        value.className = 'chart-value';
        value.textContent = day.count;
        
        bar.appendChild(value);
        bar.appendChild(label);
        chartContainer.appendChild(bar);
      });
    }
    
    // Create response usage chart
    function createResponseUsageChart() {
      const chartContainer = document.getElementById('responsesChart');
      chartContainer.innerHTML = '';
      
      // Get top 5 most used responses
      const patterns = Object.keys(analyticsData.patternUsage)
        .map(key => ({ pattern: key, count: analyticsData.patternUsage[key] }))
        .sort((a, b) => b.count - a.count)
        .slice(0, 5);
      
      // Find max for scaling
      const maxCount = patterns.length > 0 ? patterns[0].count : 0;
      
      // Create bars
      patterns.forEach(pattern => {
        const barHeight = maxCount > 0 ? (pattern.count / maxCount * 100) : 0;
        
        const bar = document.createElement('div');
        bar.className = 'chart-bar';
        bar.style.height = `${Math.max(barHeight, 5)}%`;
        
        const label = document.createElement('div');
        label.className = 'chart-bar-label';
        label.textContent = pattern.pattern.substring(0, 10) + (pattern.pattern.length > 10 ? '...' : '');
        label.title = pattern.pattern;
        
        const value = document.createElement('div');
        value.className = 'chart-value';
        value.textContent = pattern.count;
        
        bar.appendChild(value);
        bar.appendChild(label);
        chartContainer.appendChild(bar);
      });
    }
    
    // Track a conversation interaction
    function trackInteraction(userMessage, botResponse, learned = false) {
      analyticsData.totalInteractions++;
      
      if (botResponse === "I don't understand that yet.") {
        analyticsData.failedResponses++;
      } else {
        analyticsData.successfulResponses++;
        
        // Track pattern usage
        const lowerMsg = userMessage.toLowerCase();
        if (trainingData[lowerMsg]) {
          analyticsData.patternUsage[lowerMsg] = (analyticsData.patternUsage[lowerMsg] || 0) + 1;
        }
      }
      
      if (learned) {
        analyticsData.learningEvents++;
      }
      
      // Add to response history (keep last 100 interactions)
      analyticsData.responseHistory.push({
        timestamp: new Date().toISOString(),
        query: userMessage,
        response: botResponse,
        learned: learned
      });
      
      // Trim history to last 100 items
      if (analyticsData.responseHistory.length > 100) {
        analyticsData.responseHistory = analyticsData.responseHistory.slice(-100);
      }
      
      saveAnalytics();
    }
    
    // Update the existing learnFromConversation function to track learning events
    const originalLearnFromConversation = learnFromConversation;
    learnFromConversation = function() {
      const originalTrainingSize = Object.keys(trainingData).length;
      originalLearnFromConversation();
      const newTrainingSize = Object.keys(trainingData).length;
      
      // If new training data was added, track it
      if (newTrainingSize > originalTrainingSize) {
        const lastUserMsg = conversationHistory[conversationHistory.length - 2];
        const lastBotMsg = conversationHistory[conversationHistory.length - 1];
        
        trackInteraction(lastUserMsg.text, lastBotMsg.text, true);
      }
    };
    
    // Modify the sendBtn event listener to track interactions
    document.getElementById('sendBtn').addEventListener('click', async function() {
      var input = document.getElementById('userInput');
      var userText = input.value.trim();
      if(userText !== "") {
        addMessage("User", userText);
        // Add to conversation history
        conversationHistory.push({ sender: 'User', text: userText });
        
        // Clear input immediately for better UX
        input.value = "";
        
        // Handle potential async response
        var response = await botResponse(userText);
        
        // For HTML content in responses (like definition sources)
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = response;
        const plainText = tempDiv.textContent || tempDiv.innerText;
        
        addMessage("Bot", response);
        // Add to conversation history (only the text part)
        conversationHistory.push({ sender: 'Bot', text: plainText });
        
        // Track this interaction
        trackInteraction(userText, plainText);
        
        // Trim conversation history
        if(conversationHistory.length > maxHistoryLength * 2) {
          conversationHistory = conversationHistory.slice(-maxHistoryLength * 2);
        }
        
        // Try to learn from this exchange
        learnFromConversation();
      }
    });
    
    // Initialize personality settings
    var personalitySettings = JSON.parse(localStorage.getItem('chatbotPersonality')) || {
      formality: 50,
      verbosity: 50,
      empathy: 70
    };
    
    // Initialize synonyms structure
    var synonymGroups = JSON.parse(localStorage.getItem('chatbotSynonyms')) || {
      "greetings": ["hello", "hi", "hey", "howdy", "greetings"],
      "farewells": ["goodbye", "bye", "see you", "farewell", "later"],
      "affirmations": ["yes", "sure", "okay", "definitely", "absolutely"]
    };
    
    // Initialize categories for training data
    var trainingCategories = JSON.parse(localStorage.getItem('chatbotCategories')) || {};
    
    // Save synonym groups
    function saveSynonyms() {
      localStorage.setItem('chatbotSynonyms', JSON.stringify(synonymGroups));
    }
    
    // Save personality settings
    function savePersonality() {
      localStorage.setItem('chatbotPersonality', JSON.stringify(personalitySettings));
    }
    
    // Save training categories
    function saveCategories() {
      localStorage.setItem('chatbotCategories', JSON.stringify(trainingCategories));
    }
    
    // Enhanced botResponse function with personality influence
    async function botResponse(message) {
      var lowerMsg = message.toLowerCase();
      
      // Apply synonym replacement - check if any word in the message is in a synonym group
      Object.keys(synonymGroups).forEach(groupName => {
        synonymGroups[groupName].forEach(synonym => {
          // Create a regex that matches the synonym as a whole word
          const regex = new RegExp(`\\b${synonym}\\b`, 'i');
          if (regex.test(lowerMsg)) {
            // For matching purposes, we'll check if the primary synonym (first in group) is in training data
            const primarySynonym = synonymGroups[groupName][0];
            const msgWithPrimarySynonym = lowerMsg.replace(regex, primarySynonym);
            
            // If there's a direct match with the primary synonym substitution, use that
            if (trainingData[msgWithPrimarySynonym]) {
              lowerMsg = msgWithPrimarySynonym;
            }
          }
        });
      });
      
      if(lowerMsg.startsWith("train:")) {
        return trainBot(message);
      }
      
      if(lowerMsg.startsWith("forget:")) {
        var key = lowerMsg.substring(7).trim();
        if(trainingData.hasOwnProperty(key)) {
          delete trainingData[key];
          saveTrainingData();
          return "Forgot about: " + key;
        } else if(wordMeanings.hasOwnProperty(key)) {
          delete wordMeanings[key];
          saveWordMeanings();
          return "Forgot the definition of: " + key;
        }
        return "I don't know anything about that.";
      }
      
      // Update context memory
      updateContext(message);
      
      // Check if asking for a word definition
      const wordDefinition = checkForWordDefinitions(message);
      if(wordDefinition) {
        return wordDefinition;
      }
      
      // Direct match in training data
      if(trainingData.hasOwnProperty(lowerMsg)) {
        let response = trainingData[lowerMsg];
        
        // Apply personality modifiers to the response
        response = applyPersonalityToResponse(response);
        
        return response;
      }
      
      // Try to find a similar question
      const bestMatch = findBestMatch(lowerMsg);
      if(bestMatch) {
        return trainingData[bestMatch];
      }
      
      // Try to find a word in the message to define if it looks like a definition request
      if(lowerMsg.includes("what") || lowerMsg.includes("define") || lowerMsg.includes("meaning")) {
        // Extract potential word to define (simple approach)
        const words = lowerMsg.split(/\W+/).filter(w => w.length > 3);
        
        // Try each word
        for(const word of words) {
          // Skip common question words
          if(['what', 'when', 'where', 'define', 'meaning', 'means', 'know', 'tell'].includes(word))
            continue;
            
          // Add loading indicator
          addMessage("Bot", "Let me look that up for you...");
          
          // Try to fetch definition
          const onlineDefinition = await fetchDefinition(word);
          
          if(onlineDefinition) {
            // Update UI to remove the loading message
            document.getElementById('chatbox').lastChild.remove();
            
            // Add the word to our known words
            wordMeanings[word] = onlineDefinition.definition;
            saveWordMeanings();
            
            return `"${word}" means: ${onlineDefinition.definition}\n\n<div class="definition-source">Source: ${onlineDefinition.source}</div>`;
          }
          
          // If we tried a lookup but failed, remove the loading message
          document.getElementById('chatbox').lastChild.remove();
        }
      }
      
      // Basic predefined responses
      if(lowerMsg.includes("hi") || lowerMsg.includes("hello")) {
        return "Hello! How can I help you today?";
      } else if(lowerMsg.includes("how are you")) {
        return "I'm a bot, so I'm always good.";
      } else if(lowerMsg.includes("bye")) {
        return "Goodbye!";
      } else {
        return "I don't understand that yet.";
      }
    }
    
    // Apply personality traits to responses
    function applyPersonalityToResponse(response) {
      // This function would modify the response based on personality settings
      
      // For formality: Add or remove formal language elements
      if (personalitySettings.formality > 75) {
        // More formal language
        response = response.replace(/yeah/gi, "yes")
                          .replace(/nope/gi, "no")
                          .replace(/hey/gi, "hello")
                          .replace(/guys/gi, "everyone");
        
        if (!response.endsWith('.') && !response.endsWith('!') && !response.endsWith('?')) {
          response += '.';
        }
      } else if (personalitySettings.formality < 25) {
        // More casual language
        response = response.replace(/hello/gi, "hey")
                          .replace(/goodbye/gi, "bye")
                          .replace(/certainly/gi, "sure");
      }
      
      // For verbosity: Make responses longer or shorter
      if (personalitySettings.verbosity > 75 && response.length < 100) {
        // Add more detail for high verbosity
        response += " I'm happy to provide more details if you'd like.";
      } else if (personalitySettings.verbosity < 25 && response.length > 60) {
        // Shorten for low verbosity
        response = response.split('.')[0] + (response.includes('.') ? '.' : '');
      }
      
      // For empathy: Add empathetic phrases for high empathy
      if (personalitySettings.empathy > 75) {
        // Add empathetic elements
        if (Math.random() > 0.5) {
          response = "I understand. " + response;
        } else if (!response.includes("hope") && Math.random() > 0.7) {
          response += " I hope that helps!";
        }
      }
      
      return response;
    }
    
    // Update synonym groups UI
    function updateSynonymUI() {
      const container = document.getElementById('synonymContainer');
      container.innerHTML = '';
      
      Object.keys(synonymGroups).forEach(groupName => {
        const group = document.createElement('div');
        group.className = 'synonym-group';
        
        const header = document.createElement('h5');
        header.textContent = groupName;
        group.appendChild(header);
        
        const list = document.createElement('div');
        list.className = 'synonym-list';
        
        synonymGroups[groupName].forEach(synonym => {
          const chip = document.createElement('div');
          chip.className = 'synonym-chip';
          
          const text = document.createTextNode(synonym);
          chip.appendChild(text);
          
          const removeBtn = document.createElement('span');
          removeBtn.className = 'remove-synonym';
          removeBtn.textContent = 'Ã—';
          removeBtn.onclick = function() {
            // Remove this synonym from the group
            const index = synonymGroups[groupName].indexOf(synonym);
            if (index > -1) {
              synonymGroups[groupName].splice(index, 1);
              saveSynonyms();
              updateSynonymUI();
            }
          };
          
          chip.appendChild(removeBtn);
          list.appendChild(chip);
        });
        
        group.appendChild(list);
        
        // Add form to add new synonyms to this group
        const addForm = document.createElement('div');
        addForm.className = 'add-synonym-form';
        
        const input = document.createElement('input');
        input.type = 'text';
        input.placeholder = 'Add new synonym';
        input.className = 'add-synonym-input';
        
        const addBtn = document.createElement('button');
        addBtn.textContent = 'Add';
        addBtn.className = 'function-btn';
        addBtn.onclick = function() {
          const newSynonym = input.value.trim().toLowerCase();
          if (newSynonym && !synonymGroups[groupName].includes(newSynonym)) {
            synonymGroups[groupName].push(newSynonym);
            saveSynonyms();
            updateSynonymUI();
          }
          input.value = '';
        };
        
        addForm.appendChild(input);
        addForm.appendChild(addBtn);
        group.appendChild(addForm);
        
        container.appendChild(group);
      });
    }
    
    // Process bulk training data
    function processBulkTraining() {
      const bulkText = document.getElementById('bulkTraining').value.trim();
      const category = document.getElementById('bulkCategory').value;
      let customCategory = '';
      
      if (category === 'custom') {
        customCategory = document.getElementById('customCategory').value.trim();
        if (!customCategory) {
          document.getElementById('bulkResult').textContent = 'Please enter a custom category name.';
          document.getElementById('bulkResult').className = 'validation-message';
          return;
        }
      }
      
      const finalCategory = category === 'custom' ? customCategory : category;
      
      if (!bulkText) {
        document.getElementById('bulkResult').textContent = 'Please enter some training data.';
        document.getElementById('bulkResult').className = 'validation-message';
        return;
      }
      
      const lines = bulkText.split('\n');
      let successCount = 0;
      let failCount = 0;
      
      lines.forEach(line => {
        if (!line.trim()) return; // Skip empty lines
        
        // Parse the line: Q: question | A: answer
        const match = line.match(/Q:\s*(.*?)\s*\|\s*A:\s*(.*)/i);
        if (match && match[1] && match[2]) {
          const question = match[1].trim();
          const answer = match[2].trim();
          
          // Add to training data
          trainingData[question.toLowerCase()] = answer;
          
          // Add category if specified
          if (finalCategory) {
            if (!trainingCategories[finalCategory]) {
              trainingCategories[finalCategory] = [];
            }
            trainingCategories[finalCategory].push(question.toLowerCase());
          }
          
          successCount++;
        } else {
          failCount++;
        }
      });
      
      saveTrainingData();
      saveCategories();
      
      const resultMsg = `Processed ${successCount + failCount} lines: ${successCount} successful, ${failCount} failed.`;
      document.getElementById('bulkResult').textContent = resultMsg;
      document.getElementById('bulkResult').className = failCount > 0 ? 'validation-message' : 'success-message';
      
      // Update UI
      updateTrainingList();
      updateTrainingStats();
    }
    
    // Initialize personality sliders
    function initPersonalitySliders() {
      document.getElementById('formalitySlider').value = personalitySettings.formality;
      document.getElementById('verbositySlider').value = personalitySettings.verbosity;
      document.getElementById('empathySlider').value = personalitySettings.empathy;
    }
    
    // Event handlers for new advanced training features
    document.addEventListener('DOMContentLoaded', function() {
      // Save personality settings
      document.getElementById('savePersonalityBtn').addEventListener('click', function() {
        personalitySettings.formality = parseInt(document.getElementById('formalitySlider').value);
        personalitySettings.verbosity = parseInt(document.getElementById('verbositySlider').value);
        personalitySettings.empathy = parseInt(document.getElementById('empathySlider').value);
        
        savePersonality();
        addMessage('Bot', 'Personality settings saved. You should notice changes in my response style.');
      });
      
      // Process bulk training
      document.getElementById('processBulkBtn').addEventListener('click', processBulkTraining);
      
      // Handle custom category selection
      document.getElementById('bulkCategory').addEventListener('change', function() {
        document.getElementById('customCategory').style.display = 
          this.value === 'custom' ? 'block' : 'none';
      });
      
      // Add new synonym group
      document.getElementById('addSynonymGroupBtn').addEventListener('click', function() {
        const groupName = document.getElementById('newSynonymGroup').value.trim();
        
        if (groupName && !synonymGroups[groupName]) {
          synonymGroups[groupName] = [];
          saveSynonyms();
          updateSynonymUI();
          document.getElementById('newSynonymGroup').value = '';
        }
      });
      
      // Initialize UI elements
      initPersonalitySliders();
    });
    
    // Auto-learning tracking
    var learningEvents = JSON.parse(localStorage.getItem('chatbotLearningEvents')) || [];
    const MAX_LEARNING_EVENTS = 20;
    
    function saveLearnEvents() {
      localStorage.setItem('chatbotLearningEvents', JSON.stringify(learningEvents));
    }
    
    function addLearningEvent(type, content) {
      // Add new learning event
      learningEvents.unshift({
        timestamp: new Date().toISOString(),
        type: type,
        content: content
      });
      
      // Limit size of learning events array
      if (learningEvents.length > MAX_LEARNING_EVENTS) {
        learningEvents = learningEvents.slice(0, MAX_LEARNING_EVENTS);
      }
      
      saveLearnEvents();
      updateLearningLog();
      
      // Update learning counters
      document.getElementById('conversationLearned').textContent = 
        learningEvents.filter(e => e.type === 'conversation').length;
      document.getElementById('wordsLearned').textContent = 
        learningEvents.filter(e => e.type === 'word').length;
    }
    
    // Update learning log display
    function updateLearningLog() {
      const logContainer = document.getElementById('learningLog');
      logContainer.innerHTML = '';
      
      if(learningEvents.length === 0) {
        logContainer.innerHTML = '<div class="learning-event">No learning events yet</div>';
        return;
      }
      
      learningEvents.forEach(event => {
        const item = document.createElement('div');
        item.className = 'learning-event';
        
        const date = new Date(event.timestamp);
        const timeStr = date.toLocaleTimeString();
        
        if(event.type === 'conversation') {
          item.textContent = `${timeStr} - Learned response for: "${event.content}"`;
        } else if(event.type === 'word') {
          item.textContent = `${timeStr} - Learned definition for: "${event.content}"`;
        }
        
        logContainer.appendChild(item);
      });
      
      // Update counters
      document.getElementById('conversationLearned').textContent = 
        learningEvents.filter(e => e.type === 'conversation').length;
      document.getElementById('wordsLearned').textContent = 
        learningEvents.filter(e => e.type === 'word').length;
    }
    
    // Override learnFromConversation to track auto-learning
    const superLearnFromConversation = learnFromConversation;
    learnFromConversation = function() {
      if(!document.getElementById('autoLearnToggle').checked ||
         !document.getElementById('useConversationsSource').checked) {
        return; // Skip learning if auto-learn or conversation source is disabled
      }
      
      const originalTrainingSize = Object.keys(trainingData).length;
      superLearnFromConversation();
      const newTrainingSize = Object.keys(trainingData).length;
      
      // If new training data was added, track it
      if (newTrainingSize > originalTrainingSize && conversationHistory.length >= 2) {
        const lastUserMsg = conversationHistory[conversationHistory.length - 2];
        addLearningEvent('conversation', lastUserMsg.text);
      }
    };
    
    // Enhanced fetchDefinition to track word learning
    const originalFetchDefinition = fetchDefinition;
    fetchDefinition = async function(word) {
      if(!document.getElementById('useOnlineSource').checked) {
        return null; // Skip online lookup if source is disabled
      }
      
      const result = await originalFetchDefinition(word);
      
      if(result) {
        // Track word learning event
        addLearningEvent('word', word);
      }
      
      return result;
    };
    
    // Initialize auto-learning display 
    function initAutoLearningDisplay() {
      updateLearningLog();
      document.getElementById('autoLearnToggle').checked = true;
      document.getElementById('useConversationsSource').checked = true;
      document.getElementById('useOnlineSource').checked = true;
    }
    
    // Update window.onload to initialize all new UI components
    const originalOnload = window.onload;
    window.onload = function() {
      originalOnload();
      initAutoLearningDisplay();
      updateSynonymUI();
      initPersonalitySliders();
    };
    
    // Initialize source settings
    var sourceSettings = JSON.parse(localStorage.getItem('chatbotSources')) || {
      advancedSourcesEnabled: true,
      dictionary: {
        local: true,
        online: true,
        userDefined: true
      },
      conversation: {
        pretrained: true,
        userTrained: true,
        inferred: true
      },
      learning: {
        mode: 'balanced',
        confidenceThreshold: 70
      },
      stats: {
        autoLearned: 0
      }
    };
    
    // Save source settings
    function saveSourceSettings() {
      localStorage.setItem('chatbotSources', JSON.stringify(sourceSettings));
    }
    
    // Update source settings UI
    function updateSourceSettingsUI() {
      // Update toggle states
      document.getElementById('advancedSourceToggle').checked = sourceSettings.advancedSourcesEnabled;
      document.getElementById('localDictionarySource').checked = sourceSettings.dictionary.local;
      document.getElementById('onlineDictionarySource').checked = sourceSettings.dictionary.online;
      document.getElementById('userDefinitionsSource').checked = sourceSettings.dictionary.userDefined;
      document.getElementById('pretrainedSource').checked = sourceSettings.conversation.pretrained;
      document.getElementById('userTrainingSource').checked = sourceSettings.conversation.userTrained;
      document.getElementById('inferredSource').checked = sourceSettings.conversation.inferred;
      document.getElementById('learningMode').value = sourceSettings.learning.mode;
      document.getElementById('confidenceThreshold').value = sourceSettings.learning.confidenceThreshold;
      
      // Update stats display
      document.getElementById('autoLearnedCount').textContent = sourceSettings.stats.autoLearned;
      document.getElementById('confidenceDisplay').textContent = sourceSettings.learning.confidenceThreshold + '%';
      
      // Update learning mode display
      const modeMap = {
        'conservative': 'Conservative',
        'balanced': 'Balanced',
        'aggressive': 'Aggressive'
      };
      document.getElementById('learningModeDisplay').textContent = modeMap[sourceSettings.learning.mode];
      
      // Update active sources display
      updateActiveSourcesDisplay();
      
      // Update confidence marker position
      document.querySelector('.confidence-marker').style.left = sourceSettings.learning.confidenceThreshold + '%';
    }
    
    // Update active sources display
    function updateActiveSourcesDisplay() {
      const activeSourcesContainer = document.getElementById('activeSourcesDisplay');
      activeSourcesContainer.innerHTML = '';
      
      // Add badges for active dictionary sources
      if (sourceSettings.dictionary.local) {
        addSourceBadge(activeSourcesContainer, 'Local');
      }
      if (sourceSettings.dictionary.online) {
        addSourceBadge(activeSourcesContainer, 'Online');
      }
      if (sourceSettings.dictionary.userDefined) {
        addSourceBadge(activeSourcesContainer, 'User');
      }
      
      // Add badges for active conversation sources
      if (sourceSettings.conversation.pretrained) {
        addSourceBadge(activeSourcesContainer, 'Pre');
      }
      if (sourceSettings.conversation.userTrained) {
        addSourceBadge(activeSourcesContainer, 'Train');
      }
      if (sourceSettings.conversation.inferred) {
        addSourceBadge(activeSourcesContainer, 'Infer');
      }
    }
    
    // Helper to create source badges
    function addSourceBadge(container, text) {
      const badge = document.createElement('span');
      badge.className = 'small-badge';
      badge.textContent = text;
      container.appendChild(badge);
    }
    
    // Enhanced fetchDefinition to consider source settings
    const originalFetchDef = fetchDefinition;
    fetchDefinition = async function(word) {
      // Don't use online lookup if advanced sources are disabled or online dictionary is off
      if(!sourceSettings.advancedSourcesEnabled || 
         !sourceSettings.dictionary.online || 
         !document.getElementById('onlineLookupToggle').checked) {
        return null;
      }
      
      const result = await originalFetchDef(word);
      
      if(result) {
        // Track word learning event
        addLearningEvent('word', word);
        
        // Count as auto-learned
        sourceSettings.stats.autoLearned++;
        saveSourceSettings();
      }
      
      return result;
    };
    
    // Enhanced learnFromConversation function with source settings
    const advancedLearnFromConversation = learnFromConversation;
    learnFromConversation = function() {
      // Check if we should use advanced learning
      if(!sourceSettings.advancedSourcesEnabled ||
         !sourceSettings.conversation.inferred) {
        // Fall back to original behavior if advanced sources are disabled
        if(document.getElementById('autoLearnToggle').checked &&
           document.getElementById('useConversationsSource').checked) {
          advancedLearnFromConversation();
        }
        return;
      }
      
      // Advanced learning based on learning mode
      if(conversationHistory.length < 2) return;
      
      const lastUserMsg = conversationHistory[conversationHistory.length - 2];
      const lastBotMsg = conversationHistory[conversationHistory.length - 1];
      
      if (lastUserMsg.sender === 'User' && lastBotMsg.sender === 'Bot' && 
          lastBotMsg.text !== "I don't understand that yet.") {
          
        // Determine if we should learn based on learning mode and confidence
        const userMsgLower = lastUserMsg.text.toLowerCase();
        let shouldLearn = false;
        
        switch(sourceSettings.learning.mode) {
          case 'aggressive':
            // Almost always learn in aggressive mode
            shouldLearn = Math.random() * 100 > 20; // 80% chance
            break;
          case 'balanced':
            // Only learn if it seems like a straightforward exchange
            shouldLearn = !userMsgLower.includes('?') && userMsgLower.length < 50 && 
                         Math.random() * 100 > 40; // 60% chance
            break;
          case 'conservative':
            // Only learn very simple and direct exchanges
            shouldLearn = userMsgLower.length < 30 && !userMsgLower.includes('?') &&
                          Math.random() * 100 > 70; // 30% chance
            break;
        }
        
        // Apply confidence threshold
        const confidence = calculateConfidence(lastUserMsg.text, lastBotMsg.text);
        if(shouldLearn && confidence >= sourceSettings.learning.confidenceThreshold) {
          if (!trainingData.hasOwnProperty(userMsgLower)) {
            trainingData[userMsgLower] = lastBotMsg.text;
            saveTrainingData();
            
            // Count as auto-learned
            sourceSettings.stats.autoLearned++;
            saveSourceSettings();
            
            // Add learning event
            addLearningEvent('conversation', userMsgLower);
          }
        }
      }
    };
    
    // Calculate confidence score for auto-learning
    function calculateConfidence(userMessage, botResponse) {
      // Basic heuristics for determining confidence
      let confidence = 50; // base confidence
      
      // Length based adjustments
      if (userMessage.length < 10) confidence -= 10; // very short queries are ambiguous
      if (userMessage.length > 100) confidence -= 15; // very long queries might be complex
      
      // Question marks reduce confidence
      if (userMessage.includes('?')) confidence -= 10;
      
      // Simple response is more likely to be correct
      if (botResponse.length < 50) confidence += 10;
      
      // Response with formatting/punctuation is likely more structured
      if (botResponse.includes(',') && botResponse.includes('.')) confidence += 5;
      
      // If it contains special characters or seems like code, reduce confidence
      if (botResponse.includes('{') || botResponse.includes('<') || 
          botResponse.includes('[') || botResponse.includes('`')) {
        confidence -= 20;
      }
      
      // Normalize to 0-100 range
      return Math.max(0, Math.min(100, confidence));
    }
    
    // Modified botResponse to consider source settings
    const enhancedBotResponse = botResponse;
    botResponse = async function(message) {
      // If advanced sources are disabled, use the original function
      if (!sourceSettings.advancedSourcesEnabled) {
        return enhancedBotResponse(message);
      }
      
      var lowerMsg = message.toLowerCase();
      
      // Apply original functionality for commands
      if(lowerMsg.startsWith("train:") || lowerMsg.startsWith("forget:")) {
        return enhancedBotResponse(message);
      }
      
      // Update context memory
      updateContext(message);
      
      // Check if asking for a word definition
      if (sourceSettings.dictionary.userDefined) {
        const wordDefinition = checkForWordDefinitions(message);
        if(wordDefinition) {
          return wordDefinition;
        }
      }
      
      // Direct match in training data (considering source settings)
      let matchedSource = null;
      
      // Check pretrained data if enabled
      if (sourceSettings.conversation.pretrained && 
          Object.prototype.hasOwnProperty.call(defaultTrainingData, lowerMsg)) {
        matchedSource = 'pretrained';
        return applyPersonalityToResponse(defaultTrainingData[lowerMsg]);
      }
      
      // Check user training data if enabled
      if (sourceSettings.conversation.userTrained && 
          trainingData.hasOwnProperty(lowerMsg)) {
        matchedSource = 'userTrained';
        return applyPersonalityToResponse(trainingData[lowerMsg]);
      }
      
      // Try to find a similar question
      if (sourceSettings.conversation.userTrained || sourceSettings.conversation.pretrained) {
        const bestMatch = findBestMatch(lowerMsg, 
                                       sourceSettings.conversation.userTrained,
                                       sourceSettings.conversation.pretrained);
        if(bestMatch) {
          matchedSource = bestMatch.source;
          return applyPersonalityToResponse(bestMatch.response);
        }
      }
      
      // Try online dictionary lookup if enabled
      if(lowerMsg.includes("what") || lowerMsg.includes("define") || lowerMsg.includes("meaning")) {
        // Extract potential word to define (simple approach)
        const words = lowerMsg.split(/\W+/).filter(w => w.length > 3);
        
        // Try each word
        for(const word of words) {
          // Skip common question words
          if(['what', 'when', 'where', 'define', 'meaning', 'means', 'know', 'tell'].includes(word))
            continue;
            
          // Add loading indicator
          addMessage("Bot", "Let me look that up for you...");
          
          // Try to fetch definition if online source is enabled
          if (sourceSettings.dictionary.online) {
            const onlineDefinition = await fetchDefinition(word);
            
            if(onlineDefinition) {
              // Update UI to remove the loading message
              document.getElementById('chatbox').lastChild.remove();
              
              // Add the word to our known words
              wordMeanings[word] = onlineDefinition.definition;
              saveWordMeanings();
              
              return `"${word}" means: ${onlineDefinition.definition}\n\n<div class="definition-source">Source: ${onlineDefinition.source}</div>`;
            }
          }
          
          // If we tried a lookup but failed, remove the loading message
          document.getElementById('chatbox').lastChild.remove();
        }
      }
      
      // Basic predefined responses
      if(lowerMsg.includes("hi") || lowerMsg.includes("hello")) {
        return "Hello! How can I help you today?";
      } else if(lowerMsg.includes("how are you")) {
        return "I'm a bot, so I'm always good.";
      } else if(lowerMsg.includes("bye")) {
        return "Goodbye!";
      } else {
        return "I don't understand that yet.";
      }
    };
    
    // Enhanced findBestMatch with source filtering
    function findBestMatch(message, includeUserTrained = true, includePretrained = true) {
      let bestMatch = null;
      let highestSimilarity = 0.5; // Threshold for considering a match
      let bestSource = null;
      
      // Search through user training data if enabled
      if (includeUserTrained) {
        Object.keys(trainingData).forEach(question => {
          const similarity = stringSimilarity(message, question);
          if (similarity > highestSimilarity) {
            highestSimilarity = similarity;
            bestMatch = question;
            bestSource = 'userTrained';
          }
        });
      }
      
      // Search through pretrained data if enabled
      if (includePretrained) {
        Object.keys(defaultTrainingData).forEach(question => {
          const similarity = stringSimilarity(message, question);
          if (similarity > highestSimilarity) {
            highestSimilarity = similarity;
            bestMatch = question;
            bestSource = 'pretrained';
          }
        });
      }
      
      if (bestMatch) {
        const response = bestSource === 'userTrained' ? 
                        trainingData[bestMatch] : 
                        defaultTrainingData[bestMatch];
        return {
          query: bestMatch,
          response: response,
          source: bestSource,
          similarity: highestSimilarity
        };
      }
      
      return null;
    }
    
    // Save pretrained data separately
    var defaultTrainingData = {};
    function preserveDefaultTraining() {
      // Clone the initial training data as default
      defaultTrainingData = JSON.parse(JSON.stringify(trainingData));
    }
    
    // Add event listeners for source settings
    document.addEventListener('DOMContentLoaded', function() {
      // Preserve the default training data on load
      preserveDefaultTraining();
      
      // Save sources button click handler
      document.getElementById('saveSourcesBtn')?.addEventListener('click', function() {
        sourceSettings.advancedSourcesEnabled = document.getElementById('advancedSourceToggle').checked;
        
        // Update dictionary sources
        sourceSettings.dictionary.local = document.getElementById('localDictionarySource').checked;
        sourceSettings.dictionary.online = document.getElementById('onlineDictionarySource').checked;
        sourceSettings.dictionary.userDefined = document.getElementById('userDefinitionsSource').checked;
        
        // Update conversation sources
        sourceSettings.conversation.pretrained = document.getElementById('pretrainedSource').checked;
        sourceSettings.conversation.userTrained = document.getElementById('userTrainingSource').checked;
        sourceSettings.conversation.inferred = document.getElementById('inferredSource').checked;
        
        // Update learning settings
        sourceSettings.learning.mode = document.getElementById('learningMode').value;
        sourceSettings.learning.confidenceThreshold = parseInt(document.getElementById('confidenceThreshold').value);
        
        saveSourceSettings();
        updateSourceSettingsUI();
        
        addMessage('Bot', 'Source settings have been saved. My learning behavior has been updated.');
      });
      
      // Confidence threshold change handler
      document.getElementById('confidenceThreshold')?.addEventListener('input', function() {
        document.querySelector('.confidence-marker').style.left = this.value + '%';
      });
    });
    
    // Update initialization to include source settings
    const existingOnload = window.onload;
    window.onload = function() {
      existingOnload();
      updateSourceSettingsUI();
    };
  </script>
</body>
</html>
